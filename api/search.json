[{"id":"6cfd9c2293bfbcc79930156aac5124e0","title":"WebStorm 2019.3.1激活码","content":"下面正式开始激活（WebStorm 2019.3.1版） WebStorm 资源链接：https://pan.baidu.com/s/1UibJECYNiFuJrG2l89c-xw  提取码：w8y7。 jetbrains-agent 资源链接：http://note.youdao.com/noteshare?id=d0bf10ac54960b8eb02c532b6ecba84f 上面是安装包，下面是补丁文件。\n\n把补丁文件 jetbrains-agent.jar 放到webStorm安装目录的bin文件夹下。 我的是默认装在C盘了：C:\\Program Files\\JetBrains\\WebStorm 2019.3.1\\bin。\n\n找到这个bin文件夹下的webstorm.exe.vmoptions和webstorm64.exe.vmoptions文件。\n\n在两个文件最后一行都加上-javaagent:。\n\n运行webStorm，输入配套的激活码：\n3AGXEJXFK9-eyJsaWNlbnNlSWQiOiIzQUdYRUpYRks5IiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly96aGlsZS5pbyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9XSwiaGFzaCI6IjEyNzk2ODc3LzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-WGTHs6XpDhr+uumvbwQPOdlxWnQwgnGaL4eRnlpGKApEEkJyYvNEuPWBSrQkPmVpim/8Sab6HV04Dw3IzkJT0yTc29sPEXBf69+7y6Jv718FaJu4MWfsAk/ZGtNIUOczUQ0iGKKnSSsfQ/3UoMv0q/yJcfvj+me5Zd/gfaisCCMUaGjB/lWIPpEPzblDtVJbRexB1MALrLCEoDv3ujcPAZ7xWb54DiZwjYhQvQ+CvpNNF2jeTku7lbm5v+BoDsdeRq7YBt9ANLUKPr2DahcaZ4gctpHZXhG96IyKx232jYq9jQrFDbQMtVr3E+GsCekMEWSD//dLT+HuZdc1sAIYrw==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g==\n\n\n激活成功后点击菜单栏Help选项下的About，出现如下界面：可以使用到2089年7月8日，是不是相当于永久激活了。\n\nPS：还是不行的话建议还是拥抱vsCode吧，基本的代码规范、格式化代码配置在这篇文章中会有详细的讲解，传送门 https://www.jianshu.com/p/c6e140d62ce8\n经过一位读者朋友的留言，大版本2020.1已经不需要注册码和修改配置文件了。直接通过拖动配置文件就可以激活，而且可以汉化简体中文，https://www.789zhao.com/blog/J7ZT190UM7ZB.html  这里我没有去尝试，大家可以试试。\n原文链接: https://www.jianshu.com/p/d120ab55bfdd\n","slug":"WebStorm","date":"2021-04-21T13:42:00.000Z","categories_index":"软件工具","tags_index":"WebStorm,软件激活","author_index":"chenin"},{"id":"d2b17992ae092d8ffe2150a17d7a79d0","title":"koa学习笔记","content":"初始化项目# 初始化package.json\nnpm init\n\n# 安装koa2 \nnpm install koa\n\nhello world 代码 const Koa = require('koa');    //引入Koa框架\n\n const app = new Koa();\n\napp.use( async ctx => &#123;\n    ctx.body = 'Hello Koa';\n&#125;)\n\n// 监听3000端口\n app.listen(3000,() => &#123;\n    console.log('Server running at port 3000!');\n &#125;)\n\n\n\nnode app.js         // 启动服务\n\n\n\nasync/await的使用function getSyncTime() &#123;\n  return new Promise((resolve, reject) => &#123;\n    try &#123;\n      let startTime = new Date().getTime()\n      setTimeout(() => &#123;\n        let endTime = new Date().getTime()\n        let data = endTime - startTime\n        resolve( data )\n      &#125;, 500)\n    &#125; catch ( err ) &#123;\n      reject( err )\n    &#125;\n  &#125;)\n&#125;\n\nasync function getSyncData() &#123;\n  let time = await getSyncTime()\n  let data = `endTime - startTime = $&#123;time&#125;`\n  return data\n&#125;\n\nasync function getData() &#123;\n  let data = await getSyncData()\n  console.log( data )\n&#125;\n\ngetData()\n\n从上述例子可以看出 async/await 的特点：\n可以让异步逻辑用同步写法实现\n最底层的await返回需要是Promise对象\n可以通过多层 async function 的同步写法代替传统的callback嵌套\n\nkoa-router中间件安装koa-router中间件npm i koa-router --save\n\nkoa-router的使用 const Koa = require('koa');    //引入Koa框架\n const Router = require('koa-router');  //引入koa-router 中间件\n\n// 实例化 app\n const app = new Koa();\n\n\n// 路由\nconst router = new Router();\n\nrouter.get('/', async (ctx) => &#123;\n    ctx.body = 'Router 请求';\n&#125;);\n\n// 配置路由\napp.use(router.routes()).use(router.allowedMethods());\n\n\n// 监听3000端口\n app.listen(3000,() => &#123;\n    console.log('Server running at port 3000!');\n &#125;)\n\n\n\n请求数据获取GTET请求数据获取 const Koa = require('koa');    //引入Koa框架\n const Router = require('koa-router');  //引入koa-router 中间件\n\n// 实例化 app\n const app = new Koa();\n\n\n// 路由\nconst router = new Router();\n\nrouter.get('/user', async (ctx) => &#123;\n    let url = ctx.url\n    // 从上下文的request对象中获取\n    let request = ctx.request\n    let req_query = request.query\n    let req_querystring = request.querystring\n\n    // 从上下文中直接获取\n    let ctx_query = ctx.query\n    let ctx_querystring = ctx.querystring\n\n    ctx.body = &#123;\n      url,\n      req_query,\n      req_querystring,\n      ctx_query,\n      ctx_querystring\n    &#125;\n&#125;);\n\n// 配置路由\napp.use(router.routes()).use(router.allowedMethods());\n\n\n// 监听3000端口\n app.listen(3000,() => &#123;\n    console.log('Server running at port 3000!');\n &#125;)\n\n\nPOST请求数据获取koa-bodyparser中间件npm install koa-body --save\n const Koa = require('koa');    //引入Koa框架\n const Router = require('koa-router');  //引入koa-router 中间件\n\n const bodyParser = require('koa-bodyparser');\n\n// 实例化 app\n const app = new Koa();\n\n // 使用ctx.body解析中间件\napp.use(bodyParser());\n/* 支持json,form,text类型\napp.use(bodyparser(&#123;\n  enableTypes:['json', 'form', 'text']\n&#125;))\n*/\n// 路由\nconst router = new Router();\n\n\nrouter.post('/login', async ctx => &#123;\n    console.log(ctx.request.body);\n&#125;)\n\n// 配置路由\napp.use(router.routes()).use(router.allowedMethods());\n\n\n// 监听3000端口\n app.listen(3000,() => &#123;\n    console.log('Server running at port 3000!');\n &#125;)\n\n\n\n静态资源加载koa-static中间件使用const Koa = require('koa');\nconst path = require('path');\nconst static = require('koa-static');\n\nconst app = new Koa();\n\n// 静态资源目录对于相对入口文件index.js的路径\nconst staticPath = './static'\n\napp.use(static(\n  path.join( __dirname,  staticPath)\n))\n\n\napp.use( async ( ctx ) => &#123;\n  ctx.body = 'hello world'\n&#125;)\n\n\napp.listen(3000);\n\n\n\nkoa-static-router中间件, 实现多个&amp;&amp;多层路由加载静态资源npm install koa-static-router\n\n简单配置app.use(static('public'))      //默认配置: &#123;dir:public  route:'/public'&#125;\n\n单个路由const static = require('koa-static-router');\n app.use(static(&#123;\n     dir,  //静态资源目录对于相对入口文件index.js的路径\n     router   //路由命名\n &#125;))\n\n多个路由访问 localhost:3000/public/image/dir/1.png\n访问 localhost:3000/static/image/dir/2.png\nconst Koa = require('koa')\nconst app = new Koa()\nconst static = require('koa-static-router');\n\n\n// 单个路由\n// app.use(static(&#123;\n//     dir:'public',\n//     router:'/static/'     //路由长度 =1\n// &#125;))\n\n\n//多个路由\napp.use(static([\n    &#123;\n    dir:'public',    //静态资源目录对于相对入口文件index.js的路径\n    router:'/public/image/'   //路由命名   路由长度 =2\n&#125;,&#123;\n    dir:'static',   //静态资源目录对于相对入口文件index.js的路径\n    router:'/static/image/'    //路由命名  路由长度 =2\n&#125;\n]))\n\napp.use( async ( ctx ) => &#123;\n  ctx.body = 'hello world'\n&#125;)\n\napp.listen(3000, () => &#123;\n  console.log('build success')\n&#125;)\n\n\n\ncookie/sessionkoa2使用cookiekoa提供了从上下文直接读取、写入cookie的方法\n\nctx.cookies.get(name, [options]) 读取上下文请求中的cookie\nctx.cookies.set(name, value, [options]) 在上下文中写入cookie\n\nkoa2 中操作的cookies是使用了npm的cookies模块，源码在https://github.com/pillarjs/cookies，所以在读写cookie的使用参数与该模块的使用一致。\nconst Koa = require('koa')\nconst app = new Koa()\n\napp.use( async ( ctx ) => &#123;\n\n  if ( ctx.url === '/index' ) &#123;\n    ctx.cookies.set(\n      'cid', \n      'hello world',\n      &#123;\n        domain: 'localhost',  // 写cookie所在的域名\n        path: '/index',       // 写cookie所在的路径\n        maxAge: 10 * 60 * 1000, // cookie有效时长\n        expires: new Date('2017-02-15'),  // cookie失效时间\n        httpOnly: false,  // 是否只用于http请求中获取\n        overwrite: false  // 是否允许重写\n      &#125;\n    )\n    ctx.body = 'cookie is ok'\n  &#125; else &#123;\n    ctx.body = 'hello world' \n  &#125;\n\n&#125;)\n\napp.listen(3000, () => &#123;\n  console.log('[demo] cookie is starting at port 3000')\n&#125;)\n\n\nkoa2实现sessionkoa2原生功能只提供了cookie的操作，但是没有提供session操作。session就只用自己实现或者通过第三方中间件实现。在koa2中实现session的方案有一下几种\n\n如果session数据量很小，可以直接存在内存中\n如果session数据量很大，则需要存储介质存放session数据\n\nkoa-session的使用npm install koa-session --save\nconst Koa = require('koa')\nconst app = new Koa()\nconst Koa_Session = require('koa-session');      \n\n// 这个是配合signed属性的签名key\nconst session_signed_key = [\"some secret hurr\"]; \n// 配置\nconst session_config = &#123;\n    key: 'koa:sess', /**  cookie的key。 (默认是 koa:sess) */\n    maxAge: 10*60*1000,   /**  session 过期时间，以毫秒ms为单位计算 。*/\n    autoCommit: true, /** 自动提交到响应头。(默认是 true) */\n    overwrite: true, /** 是否允许重写 。(默认是 true) */\n    httpOnly: true, /** 是否设置HttpOnly，如果在Cookie中设置了\"HttpOnly\"属性，那么通过程序(JS脚本、Applet等)将无法读取到Cookie信息，这样能有效的防止XSS攻击。  (默认 true) */\n    signed: true, /** 是否签名。(默认是 true) */\n    rolling: true, /** 是否每次响应时刷新Session的有效期。(默认是 false) */\n    renew: false, /** 是否在Session快过期时刷新Session的有效期。(默认是 false) */\n&#125;;\n\n// 实例化\nconst session = Koa_Session(session_config, app)\napp.keys = session_signed_key;\n\n// 使用中间件，注意有先后顺序\napp.use(session);\n\napp.use( async ( ctx ) => &#123;\n\n  let n = ctx.session.views || 0;\n    ctx.session.views = ++n;\n    ctx.session.name = 'chen';\n    ctx.body = n + ' views';\n\n&#125;)\n\napp.listen(3000, () => &#123;\n  console.log('[demo] cookie is starting at port 3000')\n&#125;)\n\n\n使用ejs模板npm i koa-ejs --save\n/**\n * 项目入口文件\n */\n\nconst Koa = require('koa');\nconst app = new Koa();\nconst bodyParser = require('koa-bodyparser');\nconst Router = require('koa-router');\nconst router = new Router();\nconst render = require('koa-ejs');\nconst path = require('path');\napp.use(bodyParser());\n\n// 初始化ejs，设置后缀为html，文件目录为`views`\nrender(app, &#123;\n    root: path.join(__dirname, 'views'),\n    layout: false,\n    viewExt: 'html',\n    cache: false,\n    debug: false\n&#125;);\n\n\n// 渲染首页\nrouter.get('/',async (ctx,next)=>&#123;\n    await ctx.render('index',&#123;\n        title: '我是首页',\n        body: '我是内容啊'\n    &#125;);\n&#125;)\n\napp.use(router.routes());\napp.use(router.allowedMethods());\n// 监听3000端口\napp.listen(3000);\n\n\n\n\n连接mysql数据库安装Sequelizenpm install mysql2 --save\nnpm install sequelize --save\n\n\n\n使用 Sequelize 初始化连接池\n创建数据表模型\n数据表控制器\n数据路由表\n解决跨域问题npm i koa2-cors --save\n\n\n\nvar koa = require('koa');\nvar app = new koa();\nvar router = require('koa-router')();\nconst cors = require('koa2-cors');\napp.use(cors(&#123;\n  origin: '*',  // 允许来自所有域名请求\n   /* origin: function (ctx) &#123;\n        if (ctx.url === '/test') &#123;\n            return \"*\"; // 允许来自所有域名请求\n        &#125;\n        return 'http://localhost:8080'; / 这样就能只允许 http://localhost:8080 这个域名的请求了\n    &#125;,*/\n  exposeHeaders: ['WWW-Authenticate', 'Server-Authorization'],\n  maxAge: 5,\n  credentials: true,\n  allowMethods: ['GET', 'POST', 'DELETE'],\n  allowHeaders: ['Content-Type', 'Authorization', 'Accept'],\n&#125;));\nrouter.post('/', async function (ctx) &#123;\n    ctx.body = '恭喜 __小简__ 你成功登陆了'\n&#125;);\n \napp\n    .use(router.routes())\n    .use(router.allowedMethods());\n \napp.listen(3000);\n\n\n\n\n实现文件上传使用koa-multer 中间件npm install koa-multer --save\nconst multer = require('koa-multer');//加载koa-multer模块\n// 上传 图片\nvar storage = multer.diskStorage(&#123;\n        //文件保存路径\n        destination: function(req, file, cb) &#123;\n            cb(null, 'public/uploads/')\n        &#125;,\n        //修改文件名称\n        filename: function(req, file, cb) &#123;\n            var fileFormat = (file.originalname).split(\".\");\n            cb(null, Date.now() + \".\" + fileFormat[fileFormat.length - 1]);\n        &#125;\n    &#125;)\n    //加载配置\nvar upload = multer(&#123;\n    storage: storage\n&#125;);\nrouter.post('/upload', upload.single('file'), async(ctx, next) => &#123;\n    ctx.body = &#123;\n        filename: ctx.req.file.filename //返回文件名\n    &#125;\n&#125;)\n\n\n\n使用 koa-body 代替 koa-bodyparser 和 koa-multernpm i koa-body -S\nconst koaBody = require('koa-body');\nconst Router = require('koa-router');\nconst app = new koa();\napp.use(koaBody(&#123;\n  multipart:true, // 支持文件上传\n  encoding:'gzip',\n  formidable:&#123;\n    uploadDir:path.join(__dirname,'public/upload/'), // 设置文件上传目录\n    keepExtensions: true,    // 保持文件的后缀\n    maxFieldsSize:2 * 1024 * 1024, // 文件上传大小\n    onFileBegin:(name,file) => &#123; // 文件上传前的设置\n      // console.log(`name: $&#123;name&#125;`);\n      // console.log(file);\n    &#125;,\n  &#125;\n&#125;));\n\nconst router = new Router();\nrouter.post('/',async (ctx)=>&#123;\n  console.log(ctx.request.files);   //上传的文件信息\n  console.log(ctx.request.body);    //上传的所有信息\n  ctx.body = JSON.stringify(ctx.request.files);\n&#125;);\n\nkoa-body 的基本参数\n\n\n参数名\n描述\n类型\n默认值\n\n\n\npatchNode\n将请求体打到原生 node.js 的ctx.req中\nBoolean\nfalse\n\n\npatchKoa\n将请求体打到 koa 的 ctx.request 中\nBoolean\ntrue\n\n\njsonLimit\nJSON 数据体的大小限制\nString / Integer\n1mb\n\n\nformLimit\n限制表单请求体的大小\nString / Integer\n56kb\n\n\ntextLimit\n限制 text body 的大小\nString / Integer\n56kb\n\n\nencoding\n表单的默认编码\nString\nutf-8\n\n\nmultipart\n是否支持 multipart-formdate 的表单\nBoolean\nfalse\n\n\nurlencoded\n是否支持 urlencoded 的表单\nBoolean\ntrue\n\n\ntext\n是否解析 text/plain 的表单\nBoolean\ntrue\n\n\njson\n是否解析 json 请求体\nBoolean\ntrue\n\n\njsonStrict\n是否使用 json 严格模式，true 会只处理数组和对象\nBoolean\ntrue\n\n\nformidable\n配置更多的关于 multipart 的选项\nObject\n&#123;&#125;\n\n\nonError\n错误处理\nFunction\nfunction()&#123;&#125;\n\n\nstict\n严格模式,启用后不会解析 GET, HEAD, DELETE 请求\nBoolean\ntrue\n\n\nformidable 的相关配置参数\n\n\n参数名\n描述\n类型\n默认值\n\n\n\nmaxFields\n限制字段的数量\nInteger\n1000\n\n\nmaxFieldsSize\n限制字段的最大大小\nInteger\n2 * 1024 * 1024\n\n\nuploadDir\n文件上传的文件夹\nString\nos.tmpDir()\n\n\nkeepExtensions\n保留原来的文件后缀\nBoolean\nfalse\n\n\nhash\n如果要计算文件的 hash，则可以选择 md5/sha1\nString\nfalse\n\n\nmultipart\n是否支持多文件上传\nBoolean\ntrue\n\n\nonFileBegin\n文件上传前的一些设置操作\nFunction\nfunction(name,file)&#123;&#125;\n\n\n图片上传成功后，获取图片const fs = require('fs')\nconst app = new Koa()\nconst router = new Router()\nconst serve = require('koa-static')\nconst koaBody = require('koa-body')\n\napp\n    .use(serve(__dirname + '/files')) // files文件夹用于保存上传的文件,也是静态资源地址\n    .use(router.routes())\n\n// 前端使用formData方式组装数据\nrouter.post('/api/upload-files', koaBody(&#123; jsonLimit: '2mb', multipart: true &#125;), async (ctx) => &#123;\n    const data = ctx.request.body.files.data;\n    const savePath = path.join(`./files`, data.name)\n    const reader = fs.createReadStream(data.path)\n    const writer = fs.createWriteStream(savePath)\n\n    const pro = new Promise( (resolve, reject) => &#123;\n        var stream = reader.pipe(writer);\n\n        stream.on('finish', function () &#123;\n            resolve(`http://当前服务器地址$&#123;data.name&#125;`);\n        &#125;);\n    &#125;)\n    \n    ctx.response.body =  await pro\n    \n&#125;)\n\nkoa-send实现文件下载const send = require('koa-send');\n\nrouter.get('/download/:name', async (ctx) => &#123;\n    const name = ctx.params.name;\n    const path = `upload/$&#123;name&#125;`;\n    ctx.attachment(path);\n    await send(ctx, path);\n&#125;);\n\nkoa中间件记录koa的错误处理   koa-onerrornpm install koa-onerror --save\nvar onerror = require('Koa-onerror');\nonerror(app);\n\nkoa日志  koa-loggerapp.use(require('koa-logger'));\n// logger\napp.use(async (ctx, next) => &#123;\n  const start = new Date()\n  await next()\n  const ms = new Date() - start\n  console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;ms&#125;ms`)\n&#125;);\n\nkoa-json美观的输出JSON response的Koa中间件 有两种使用方式： 一种是总是返回美化了的json数据：\nconst json = require('koa-json');\napp.use(json());\n\n另一种是默认不进行美化，但是当地址栏传入pretty参数的时候，则返回的结果是进行了美化的。\napp.use(json(&#123; pretty: false, param: 'pretty' &#125;));\n\n\n\nkoa-jwt和jsonwebtoken进行token验证koa-jwt 主要提供路有权限控制的功能，它会对需要限制的资源请求进行检查\ntoken 默认被携带在Headers 中的名为Authorization的键值对中，koa-jwt也是在该位置获取token 的\napp.use(jwt(&#123; secret: &#39;shared-secret&#39;, key: &#39;jwtdata&#39; &#125;)) 可以使用另外一ctx key来表示解码数据，然后就可以通过ctx.state.jwtdata代替ctx.state.user获得解码数据\n\nsecret 的值可以使用函数代替，以此产生动态的加密秘钥\nkoa-jwt 依赖于jsonwebtoken和koa-unless两个库的\n\napp.use(jwt(&#123;\n    secret:'chambers'\n&#125;).unless(&#123;path:[/^\\/api/]&#125;));\n\n\n生成tokenconst router = require('koa-router')();\nconst jwt = require('jsonwebtoken');\nconst userModel = require('../models/userModel.js');\n\nrouter.post('/login', async (ctx) => &#123;\n    const data = ctx.request.body;\n    if(!data.name || !data.password)&#123;\n        return ctx.body = &#123;\n            code: '000002',\n            data: null,\n            msg: '参数不合法'\n        &#125;\n    &#125;\n    const result = await userModel.findOne(&#123;\n        name: data.name,\n        password: data.password\n    &#125;)\n    if(result !== null)&#123;\n        const token = jwt.sign(&#123;\n            name: result.name,\n            _id: result._id\n        &#125;, 'my_token', &#123; expiresIn: '2h' &#125;);\n        return ctx.body = &#123;\n            code: '000001',\n            data: token,\n            msg: '登录成功'\n        &#125;\n    &#125;else&#123;\n        return ctx.body = &#123;\n            code: '000002',\n            data: null,\n            msg: '用户名或密码错误'\n        &#125;\n    &#125;\n&#125;);\n\nmodule.exports = router;\n\n在验证了用户名密码正确之后，调用 jsonwebtoken 的 sign() 方法来生成token，接收三个参数，第一个是载荷，用于编码后存储在 token 中的数据，也是验证 token 后可以拿到的数据；第二个是密钥，自己定义的，验证的时候也是要相同的密钥才能解码；第三个是options，可以设置 token 的过期时间。\njwt.decode(token); 可以解析出sign（）中第一个参数。\n获取token前端请求头在Authorization中携带token，用于后台验证\n每次请求都要获取 localStorage 中的 token，这样很麻烦，这里使用了 axios 的请求拦截器，对每次请求都进行了取 token 放到 headers 中的操作。\naxios.interceptors.request.use(config => &#123;\n    const token = localStorage.getItem('token');\n    config.headers.common['Authorization'] = 'Bearer ' + token;\n    return config;\n&#125;)\n\n验证token通过 koa-jwt 中间件来进行验证\nconst koa = require('koa');\nconst koajwt = require('koa-jwt');\nconst app = new koa();\n\n// 错误处理\napp.use((ctx, next) => &#123;\n    return next().catch((err) => &#123;\n        if(err.status === 401)&#123;\n            ctx.status = 401;\n            ctx.body = 'Protected resource, use Authorization header to get access\\n';\n        &#125;else&#123;\n            throw err;\n        &#125;\n    &#125;)\n&#125;)\n\napp.use(koajwt(&#123;\n    secret: 'my_token'\n&#125;).unless(&#123;\n    path: [/\\/user\\/login/]\n&#125;));\n\n通过 app.use 来调用该中间件，并传入密钥 &#123;secret: &#39;my_token&#39;&#125;，unless 可以指定哪些 URL 不需要进行 token 验证。token 验证失败的时候会抛出401错误，因此需要添加错误处理，而且要放在 app.use(koajwt()) 之前，否则不执行。\n如果请求时没有token或者token过期，则会返回401。\n解析koa-jwt上面使用 jsonwebtoken 的 sign() 方法来生成 token 的，那么 koa-jwt 做了些什么帮我们来验证 token。\nresolvers/auth-header.jsmodule.exports = function resolveAuthorizationHeader(ctx, opts) &#123;\n    if (!ctx.header || !ctx.header.authorization) &#123;\n        return;\n    &#125;\n    const parts = ctx.header.authorization.split(' ');\n    if (parts.length === 2) &#123;\n        const scheme = parts[0];\n        const credentials = parts[1];\n        if (/^Bearer$/i.test(scheme)) &#123;\n            return credentials;\n        &#125;\n    &#125;\n    if (!opts.passthrough) &#123;\n        ctx.throw(401, 'Bad Authorization header format. Format is \"Authorization: Bearer &lt;token>\"');\n    &#125;\n&#125;;\n\n在 auth-header.js 中，判断请求头中是否带了 authorization，如果有，将 token 从 authorization 中分离出来。如果没有 authorization，则代表了客户端没有传 token 到服务器，这时候就抛出 401 错误状态。\nverify.jsconst jwt = require('jsonwebtoken');\n\nmodule.exports = (...args) => &#123;\n    return new Promise((resolve, reject) => &#123;\n        jwt.verify(...args, (error, decoded) => &#123;\n            error ? reject(error) : resolve(decoded);\n        &#125;);\n    &#125;);\n&#125;;\n\n在 verify.js 中，使用 jsonwebtoken 提供的 verify() 方法进行验证返回结果。jsonwebtoken 的 sign() 方法来生成 token 的，而 verify() 方法则是用来认证和解析 token。如果 token 无效，则会在此方法被验证出来。\nindex.jsconst decodedToken = await verify(token, secret, opts);\nif (isRevoked) &#123;\n    const tokenRevoked = await isRevoked(ctx, decodedToken, token);\n    if (tokenRevoked) &#123;\n        throw new Error('Token revoked');\n    &#125;\n&#125;\nctx.state[key] = decodedToken;  // 这里的key = 'user'\nif (tokenKey) &#123;\n    ctx.state[tokenKey] = token;\n&#125;\n\n在 index.js 中，调用 verify.js 的方法进行验证并解析 token，拿到上面进行 sign() 的数据 &#123;name: result.name, _id: result._id&#125;，并赋值给 ctx.state.user，在控制器中便可以直接通过 ctx.state.user 拿到 name 和 _id。\n安全性\n如果 JWT 的加密密钥泄露的话，那么就可以通过密钥生成 token，随意的请求 API 了。因此密钥绝对不能存在前端代码中，不然很容易就能被找到。\n在 HTTP 请求中，token 放在 header 中，中间者很容易可以通过抓包工具抓取到 header 里的数据。而 HTTPS 即使能被抓包，但是它是加密传输的，所以也拿不到 token，就会相对安全了。\n\nbcryptjs密码加密npm install bcryptjs --save\n\n同步用法(Sync)生成hash密码\nconst bcrypt = require('bcryptjs');\nconst salt = bcrypt.genSaltSync(10);\n// hash 加密后的密码       \"B4c0/\\/\"加密前的密码   \nvar hash = bcrypt.hashSync(\"B4c0/\\/\", salt);\n\n密码验证\nbcrypt.compareSync(\"B4c0/\\/\", hash); // true \nbcrypt.compareSync(\"not_bacon\", hash); // false\n\n快速生成hash值\nvar hash = bcrypt.hashSync('bacon', 8);\n\n异步用法(Async)生成hash密码\nvar bcrypt = require('bcryptjs');\nbcrypt.genSalt(10, function(err, salt) &#123;\n    bcrypt.hash(\"B4c0/\\/\", salt, function(err, hash) &#123;\n        // Store hash in your password DB. \n    &#125;);\n&#125;);\n\n密码验证\n// Load hash from your password DB. \nbcrypt.compare(\"B4c0/\\/\", hash, function(err, res) &#123;\n    // res === true \n&#125;);\nbcrypt.compare(\"not_bacon\", hash, function(err, res) &#123;\n    // res === false \n&#125;);\n \n// As of bcryptjs 2.4.0, compare returns a promise if callback is omitted: \nbcrypt.compare(\"B4c0/\\/\", hash).then((res) => &#123;\n    // res === true \n&#125;);\n\n快速生成hash值\nbcrypt.hash('bacon', 8, function(err, hash) &#123;\n&#125;);\n\n\n\n\n\nmoment 时间中间件markdown-it markdown语法","slug":"koa","date":"2021-04-10T10:02:55.000Z","categories_index":"Node.js","tags_index":"Koa,MySQL","author_index":"chenin"}]