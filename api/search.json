[{"id":"ddb15248561add228bd6a63ffdb86463","title":"typescript配置文件","content":"生成tsconfig.json 文件这个文件是通过tsc –init命令生成的\n配置详解\n\"compilerOptions\": &#123;\n  \"incremental\": true, // TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度\n  \"tsBuildInfoFile\": \"./buildFile\", // 增量编译文件的存储位置\n  \"diagnostics\": true, // 打印诊断信息 \n  \"target\": \"ES5\", // 目标语言的版本\n  \"module\": \"CommonJS\", // 生成代码的模板标准\n  \"outFile\": \"./app.js\", // 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，即开启时应设置\"module\": \"AMD\",\n  \"lib\": [\"DOM\", \"ES2015\", \"ScriptHost\", \"ES2019.Array\"], // TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入\"ES2019.Array\",\n  \"allowJS\": true, // 允许编译器编译JS，JSX文件\n  \"checkJs\": true, // 允许在JS文件中报错，通常与allowJS一起使用\n  \"outDir\": \"./dist\", // 指定输出目录\n  \"rootDir\": \"./\", // 指定输出文件目录(用于输出)，用于控制输出目录结构\n  \"declaration\": true, // 生成声明文件，开启后会自动生成声明文件\n  \"declarationDir\": \"./file\", // 指定生成声明文件存放目录\n  \"emitDeclarationOnly\": true, // 只生成声明文件，而不会生成js文件\n  \"sourceMap\": true, // 生成目标文件的sourceMap文件\n  \"inlineSourceMap\": true, // 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中\n  \"declarationMap\": true, // 为声明文件生成sourceMap\n  \"typeRoots\": [], // 声明文件目录，默认时node_modules/@types\n  \"types\": [], // 加载的声明文件包\n  \"removeComments\":true, // 删除注释 \n  \"noEmit\": true, // 不输出文件,即编译后不会生成任何js文件\n  \"noEmitOnError\": true, // 发送错误时不输出任何文件\n  \"noEmitHelpers\": true, // 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用\n  \"importHelpers\": true, // 通过tslib引入helper函数，文件必须是模块\n  \"downlevelIteration\": true, // 降级遍历器实现，如果目标源是es3/5，那么遍历器会有降级的实现\n  \"strict\": true, // 开启所有严格的类型检查\n  \"alwaysStrict\": true, // 在代码中注入'use strict'\n  \"noImplicitAny\": true, // 不允许隐式的any类型\n  \"strictNullChecks\": true, // 不允许把null、undefined赋值给其他类型的变量\n  \"strictFunctionTypes\": true, // 不允许函数参数双向协变\n  \"strictPropertyInitialization\": true, // 类的实例属性必须初始化\n  \"strictBindCallApply\": true, // 严格的bind/call/apply检查\n  \"noImplicitThis\": true, // 不允许this有隐式的any类型\n  \"noUnusedLocals\": true, // 检查只声明、未使用的局部变量(只提示不报错)\n  \"noUnusedParameters\": true, // 检查未使用的函数参数(只提示不报错)\n  \"noFallthroughCasesInSwitch\": true, // 防止switch语句贯穿(即如果没有break语句后面不会执行)\n  \"noImplicitReturns\": true, //每个分支都会有返回值\n  \"esModuleInterop\": true, // 允许export=导出，由import from 导入\n  \"allowUmdGlobalAccess\": true, // 允许在模块中全局变量的方式访问umd模块\n  \"moduleResolution\": \"node\", // 模块解析策略，ts默认用node的解析策略，即相对的方式导入\n  \"baseUrl\": \"./\", // 解析非相对模块的基地址，默认是当前目录\n  \"paths\": &#123; // 路径映射，相对于baseUrl\n    // 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置\n    \"jquery\": [\"node_modules/jquery/dist/jquery.min.js\"]\n  &#125;,\n  \"rootDirs\": [\"src\",\"out\"], // 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错\n  \"listEmittedFiles\": true, // 打印输出文件\n  \"listFiles\": true// 打印编译的文件(包括引用的声明文件)\n&#125;\n\n// 指定一个匹配列表（属于自动指定该路径下的所有ts相关文件）\n\"include\": [\n   \"src/**/*\"\n],\n// 指定一个排除列表（include的反向操作）\n \"exclude\": [\n   \"demo.ts\"\n],\n// 指定哪些文件使用该配置（属于手动一个个指定文件）\n \"files\": [\n   \"demo.ts\"\n]\n\n 介绍几个常用的\n1.include指定编译文件默认是编译当前目录下所有的ts文件\n2.exclude指定排除的文件\n3.target指定编译js 的版本例如es5  es6\n4.allowJS是否允许编译js文件\n5.removeComments是否在编译过程中删除文件中的注释\n6.rootDir编译文件的目录\n7.outDir输出的目录\n8.sourceMap代码源文件\n9.strict严格模式\n10.module默认common.js  可选es6模式 amd  umd 等\n","slug":"TypeScript/05.typescript配置","date":"2023-02-05T15:30:34.000Z","categories_index":"TypeScript","tags_index":"TypeScript","author_index":"chenin"},{"id":"520b2e36f5b7d18dabaa9ecbe26ea061","title":"typescript泛型","content":"泛型在TypeScript 是很重要的东西 例如vue3 是用ts编写的 里面用到了非常多的泛型\nok:我们看一个小例子\n函数泛型我写了两个函数一个是数字类型的函数，另一个是字符串类型的函数,其实就是类型不同，\n实现的功能是一样的，这时候我们就可以使用泛型来优化\nfunction num (a:number,b:number) : Array&lt;number> &#123;\n    return [a ,b];\n&#125;\nnum(1,2)\nfunction str (a:string,b:string) : Array&lt;string> &#123;\n    return [a ,b];\n&#125;\nstr('独孤','求败')\n\n泛型优化语法为函数名字后面跟一个&lt;参数名&gt; 参数名可以随便写 例如我这儿写了T\n当我们使用这个函数的时候把参数的类型传进去就可以了 （也就是动态类型）\nfunction Add&lt;T>(a: T, b: T): Array&lt;T>  &#123;\n    return [a,b]\n&#125;\n\nAdd&lt;number>(1,2)\nAdd&lt;string>('1','2')\n\n我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。\nfunction Sub&lt;T,U>(a:T,b:U):Array&lt;T|U> &#123;\n    const params:Array&lt;T|U> = [a,b]\n    return params\n&#125;\n\nSub&lt;Boolean,number>(false,1)\n\n\n\n定义泛型接口声明接口的时候 在名字后面加一个&lt;参数&gt;\n使用的时候传递类型\ninterface MyInter&lt;T> &#123;\n   (arg: T): T\n&#125;\n\nfunction fn&lt;T>(arg: T): T &#123;\n   return arg\n&#125;\n\nlet result: MyInter&lt;number> = fn\n\nresult(123)\n\n\n\n对象字面量泛型let foo: &#123; &lt;T>(arg: T): T &#125;\n\nfoo = function &lt;T>(arg:T):T &#123;\n   return arg\n&#125;\n\nfoo(123)\n\n\n\n泛型约束我们期望在一个泛型的变量上面，获取其length参数，但是，有的数据类型是没有length属性的\nfunction getLegnth&lt;T>(arg:T) &#123;\n  return arg.length\n&#125;\n\n 这时候我们就可以使用泛型约束\n于是，我们就得对使用的泛型进行约束，我们约束其为具有length属性的类型，这里我们会用到interface,代码如下\ninterface Len &#123;\n   length:number\n&#125;\n\nfunction getLegnth&lt;T extends Len>(arg:T) &#123;\n  return arg.length\n&#125;\n\ngetLegnth&lt;string>('123')\n\n\n\n使用keyof 约束对象其中使用了TS泛型和泛型约束。首先定义了T类型并使用extends关键字继承object类型的子类型，然后使用keyof操作符获取T类型的所有键，它的返回 类型是联合 类型，最后利用extends关键字约束 K类型必须为keyof T联合类型的子类型\nfunction prop&lt;T, K extends keyof T>(obj: T, key: K) &#123;\n   return obj[key]\n&#125;\n\n\nlet o = &#123; a: 1, b: 2, c: 3 &#125;\n\nprop(o, 'a') \nprop(o, 'd') //此时就会报错发现找不到\n\n\n\n泛型类声明方法跟函数类似名称后面定义&lt;类型&gt;\n使用的时候确定类型new Sub()\nclass Sub&lt;T>&#123;\n   attr: T[] = [];\n   add (a:T):T[] &#123;\n      return [a]\n   &#125;\n&#125;\n\nlet s = new Sub&lt;number>()\ns.attr = [1,2,3]\ns.add(123)\n\nlet str = new Sub&lt;string>()\nstr.attr = ['1','2','3']\nstr.add('123')\n\n","slug":"TypeScript/04.typescript泛型","date":"2023-02-05T15:20:06.000Z","categories_index":"TypeScript","tags_index":"TypeScript","author_index":"chenin"},{"id":"938498ff41c16e6a4fcfa03c651941dd","title":"typescript类型推论|类型别名","content":"TypeScript里的类型推论。即，类型是在哪里如何被推断的。\n基础TypeScript里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。如下面的例子\nlet x = 3;\n\n变量x的类型被推断为数字。 这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。\n大多数情况下，类型推论是直截了当地。 后面的小节，我们会浏览类型推论时的细微差别。\n最佳通用类型当需要从几个表达式中推断类型时候，会使用这些表达式的类型来推断出一个最合适的通用类型。例如，\nlet x = [0, 1, null];\n\n为了推断x的类型，我们必须考虑所有元素的类型。 这里有两种选择：number和null。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。\n由于最终的通用类型取自候选类型，有些时候候选类型共享相同的通用类型，但是却没有一个类型能做为所有候选类型的类型。例如：\nlet zoo = [new Rhino(), new Elephant(), new Snake()];\n\n这里，我们想让zoo被推断为Animal[]类型，但是这个数组里没有对象是Animal类型的，因此不能推断出这个结果。 为了更正，当候选类型不能使用的时候我们需要明确的指出类型：\nlet zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];\n\n如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，(Rhino | Elephant | Snake)[]。\n上下文类型TypeScript类型推论也可能按照相反的方向进行。 这被叫做“按上下文归类”。按上下文归类会发生在表达式的类型与所处的位置相关时。比如：\nwindow.onmousedown = function(mouseEvent) &#123;\n    console.log(mouseEvent.button);  //&lt;- Error\n&#125;;\n\n这个例子会得到一个类型错误，TypeScript类型检查器使用Window.onmousedown函数的类型来推断右边函数表达式的类型。 因此，就能推断出mouseEvent参数的类型了。 如果函数表达式不是在上下文类型的位置，mouseEvent参数的类型需要指定为any，这样也不会报错了。\n如果上下文类型表达式包含了明确的类型信息，上下文的类型被忽略。 重写上面的例子：\nwindow.onmousedown = function(mouseEvent: any) &#123;\n    console.log(mouseEvent.button);  //&lt;- Now, no error is given\n&#125;;\n\n这个函数表达式有明确的参数类型注解，上下文类型被忽略。 这样的话就不报错了，因为这里不会使用到上下文类型。\n上下文归类会在很多情况下使用到。 通常包含函数的参数，赋值表达式的右边，类型断言，对象成员和数组字面量和返回值语句。 上下文类型也会做为最佳通用类型的候选类型。比如：\nfunction createZoo(): Animal[] &#123;\n    return [new Rhino(), new Elephant(), new Snake()];\n&#125;\n\n这个例子里，最佳通用类型有4个候选者：Animal，Rhino，Elephant和Snake。 当然，Animal会被做为最佳通用类型。\n类型别名type 关键字（可以给一个类型定义一个名字）多用于符合类型\n 定义类型别名\ntype str = string\n\n\nlet s:str = \"我是小满\"\n\nconsole.log(s);\n\n 定义函数别名\ntype str = () => string\n\n\nlet s: str = () => \"我是小满\"\n\nconsole.log(s);\n\n 定义联合类型别名\ntype str = string | number\n\n\nlet s: str = 123\n\nlet s2: str = '123'\n\nconsole.log(s,s2);\n\n定义值的别名\ntype value = boolean | 0 | '213'\n\n\nlet s:value = true\n//变量s的值  只能是上面value定义的值\n\n","slug":"TypeScript/03.typescript类型推论","date":"2023-02-05T14:49:56.000Z","categories_index":"TypeScript","tags_index":"TypeScript","author_index":"chenin"},{"id":"5a8039b09f9d80d73cfaed9ef95a24ec","title":"typescript类（class）","content":"ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的“类”改写，就是下面这样。\n//定义类\nclass Person &#123;\n    constructor () &#123;\n\n\t&#125;\n\trun () &#123;\n\t&#125;\n\n&#125;\n\n\n\n1.如何定义类在TypeScript是不允许直接在constructor 定义变量的 需要在constructor上面先声明\n\n\n这样引发了第二个问题你如果了定义了变量不用 也会报错 通常是给个默认值 或者 进行赋值\n\n2.类的修饰符总共有三个 public private protected\n使用public 修饰符 可以让你定义的变量 内部访问 也可以外部访问 如果不写默认就是public\n使用  private 修饰符 代表定义的变量私有的只能在内部访问 不能在外部访问\n使用  protected 修饰符 代表定义的变量私有的只能在内部和继承的子类中访问 不能在外部访问\nclass Person &#123;\n    public name:string\n    private age:number \n    protected some:any\n    constructor (name:string,ages:number,some:any) &#123;\n       this.name = name\n       this.age = ages\n       this.some = some\n    &#125;\n    run () &#123;\n\n\t&#125;\n\n&#125;\n\nclass Man extends Person&#123;\n    constructor () &#123;\n        super(\"张三\",18,1)\n        console.log(this.some)\n    &#125;\n    create () &#123;\n       console.log(this.some)\n    &#125;\n&#125;\nlet xiaoman = new Person('小满',18,1)\nlet man = new Man()\nman.some\n\n\n\n3.static 静态属性 和 静态方法\n我们用static 定义的属性 不可以通过this 去访问 只能通过类名去调用\n\nstatic 静态函数 同样也是不能通过this 去调用 也是通过类名去调用\n\n需注意： 如果两个函数都是static 静态的是可以通过this互相调用\n\n4.interface 定义类 ts interface 定义类 使用关键字 implements   后面跟interface的名字多个用逗号隔开 继承还是用extends\ninterface PersonClass &#123;\n    get(type: boolean): boolean\n&#125;\n\ninterface PersonClass2&#123;\n    set():void,\n    asd:string\n&#125;\n\nclass A &#123;\n    name: string\n    constructor() &#123;\n        this.name = \"123\"\n    &#125;\n&#125;\n\nclass Person extends A implements PersonClass,PersonClass2 &#123;\n    asd: string\n    constructor() &#123;\n        super()\n        this.asd = '123'\n    &#125;\n    get(type:boolean) &#123;\n        return type\n    &#125;\n    set () &#123;\n\t&#125;\n&#125;\n\n\n5.抽象类应用场景如果你写的类实例化之后毫无用处此时我可以把他定义为抽象类\n或者你也可以把他作为一个基类-&gt; 通过继承一个派生类去实现基类的一些方法\n我们看例子\n下面这段代码会报错抽象类无法被实例化\nabstract class A &#123;\n   public name:string\n\n&#125;\n\nnew A()\n\n例子2\n我们在A类定义了 getName 抽象方法但为实现\n我们B类实现了A定义的抽象方法 如不实现就不报错 我们定义的抽象方法必须在派生类实现\nabstract class A &#123;\n   name: string\n   constructor(name: string) &#123;\n      this.name = name;\n   &#125;\n   print(): string &#123;\n      return this.name\n   &#125;\n\n   abstract getName(): string\n&#125;\n\nclass B extends A &#123;\n   constructor() &#123;\n      super('小满')\n   &#125;\n   getName(): string &#123;\n      return this.name\n   &#125;\n&#125;\n\nlet b = new B();\n\nconsole.log(b.getName());\n\n","slug":"TypeScript/02.typescript类（class）","date":"2023-02-05T11:30:32.000Z","categories_index":"TypeScript","tags_index":"TypeScript","author_index":"chenin"},{"id":"92b2261d7a01551b4d1eedb33cf3ba36","title":"typescript数据类型","content":"基础数据类型TS是JS的超集，所以JS基础的类型都包含在内\n起步安装 npm install typescript -g\n运行tsc 文件名\n基础类型：Boolean、Number、String、null、undefined 以及 ES6 的 Symbol 和 ES10 的 BigInt。\n1.字符串类型字符串是使用string定义的\nlet a: string = '123'\n//普通声明\n \n//也可以使用es6的字符串模板\nlet str: string = `dddd$&#123;a&#125;`\n\n2.数字类型支持十六进制、十进制、八进制和二进制；\nlet notANumber: number = NaN;//Nan\nlet num: number = 123;//普通数字\nlet infinityNumber: number = Infinity;//无穷大\nlet decimal: number = 6;//十进制\nlet hex: number = 0xf00d;//十六进制\nlet binary: number = 0b1010;//二进制\nlet octal: number = 0o744;//八进制s\n\n3.布尔类型注意，使用构造函数 Boolean 创造的对象不是布尔值：\nlet createdBoolean: boolean = new Boolean(1)\n//这样会报错 应为事实上 new Boolean() 返回的是一个 Boolean 对象 \n\n\n\n事实上 new Boolean() 返回的是一个 Boolean 对象 需要改成\nlet createdBoolean: Boolean = new Boolean(1)\nlet booleand: boolean = true //可以直接使用布尔值\n\nlet booleand2: boolean = Boolean(1) //也可以通过函数返回布尔值\n\n4.空值类型JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数\nfunction voidFn(): void &#123;\n    console.log('test void')\n&#125;\n\nvoid 类型的用法，主要是用在我们不希望调用者关心函数返回值的情况下，比如通常的异步回调函数void也可以定义undefined 和 null类型\nlet u: void = undefined\nlet n: void = null;\n\nTIPS 注意：\n\n\n\n\n\n\n\n\n\n如果你配置了tsconfig.json 开启了严格模式\n{    “compilerOptions”:{        “strict”: true    }} null 不能 赋予 void 类型 \n5.Null和undefined类型let u: undefined = undefined;//定义undefined\nlet n: null = null;//定义null\n\nvoid 和 undefined 和 null 最大的区别与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 string 类型的变量：\n//这样写会报错 void类型不可以分给其他类型\nlet test: void = undefined\nlet num2: string = \"1\"\n\nnum2 = test\n//这样是没问题的\nlet test: null = null\nlet num2: string = \"1\"\n\nnum2 = test\n\n//或者这样的\nlet test: undefined = undefined\nlet num2: string = \"1\"\n\nnum2 = test\n\n任意类型Any 类型 和 unknown 顶级类型1.没有强制限定哪种类型，随时切换类型都可以 我们可以对 any 进行任何操作，不需要检查类型\nlet anys:any = 123\nanys = '123'\nanys = true\n\n2.声明变量的时候没有指定任意类型默认为any\nlet anys;\nanys = '123'\nanys = true\n\n3.弊端如果使用any 就失去了TS类型检测的作用\n4.TypeScript 3.0中引入的 unknown 类型也被认为是 top type ，但它更安全。与 any 一样，所有类型都可以分配给unknown\nunknow  unknow类型比any更加严格当你要使用any 的时候可以尝试使用unknow\n//unknown 可以定义任何类型的值\nlet value: unknown;\n\nvalue = true;             // OK\nvalue = 42;               // OK\nvalue = \"Hello World\";    // OK\nvalue = [];               // OK\nvalue = &#123;&#125;;               // OK\nvalue = null;             // OK\nvalue = undefined;        // OK\nvalue = Symbol(\"type\");   // OK\n\n//这样写会报错unknow类型不能作为子类型只能作为父类型 any可以作为父类型和子类型\n//unknown类型不能赋值给其他类型\nlet names:unknown = '123'\nlet names2:string = names\n\n//这样就没问题 any类型是可以的\nlet names:any = '123'\nlet names2:string = names   \n\n//unknown可赋值对象只有unknown 和 any\nlet bbb:unknown = '123'\nlet aaa:any= '456'\n\naaa = bbb\n\n\n\n区别2\n如果是any类型在对象没有这个属性的时候还在获取是不会报错的\nlet obj:any = &#123;b:1&#125;\nobj.a\n\n如果是unknow 是不能调用属性和方法\nlet obj:unknown = &#123;b:1,ccc:():number=>213&#125;\nobj.b\nobj.ccc()\n\n接口和对象类型对象的类型在typescript中，我们定义对象的方式要用关键字interface（接口），我的理解是使用interface来定义一种约束，让数据的结构满足约束的格式。定义方式如下：\n//这样写是会报错的 因为我们在person定义了a，b但是对象里面缺少b属性\n//使用接口约束的时候不能多一个属性也不能少一个属性\n//必须与接口保持一致\ninterface Person &#123;\n    b:string,\n    a:string\n&#125;\n\nconst person:Person  = &#123;\n    a:\"213\"\n&#125;\n\n//重名interface  可以合并\ninterface A&#123;name:string&#125;\ninterface A&#123;age:number&#125;\nvar x:A=&#123;name:'xx',age:20&#125;\n//继承\ninterface A&#123;\n    name:string\n&#125;\n\ninterface B extends A&#123;\n    age:number\n&#125;\n\nlet obj:B = &#123;\n    age:18,\n    name:\"string\"\n&#125;\n\n可选属性 使用?操作符//可选属性的含义是该属性可以不存在\n//所以说这样写也是没问题的\ninterface Person &#123;\n    b?:string,\n    a:string\n&#125;\n\nconst person:Person  = &#123;\n    a:\"213\"\n&#125;\n\n任意属性 [propName: string]需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集：\n//在这个例子当中我们看到接口中并没有定义C但是并没有报错\n//应为我们定义了[propName: string]: any;\n//允许添加新的任意属性\ninterface Person &#123;\n    b?:string,\n    a:string,\n    [propName: string]: any;\n&#125;\n\nconst person:Person  = &#123;\n    a:\"213\",\n    c:\"123\"\n&#125;\n\n只读属性 readonlyreadonly 只读属性是不允许被赋值的只能读取\n//这样写是会报错的\n//应为a是只读的不允许重新赋值\ninterface Person &#123;\n    b?: string,\n    readonly a: string,\n    [propName: string]: any;\n&#125;\n\nconst person: Person = &#123;\n    a: \"213\",\n    c: \"123\"\n&#125;\n\nperson.a = 123\n\n添加函数interface Person &#123;\n    b?: string,\n    readonly a: string,\n\n[propName: string]: any;\n\n    cb:()=>void\n&#125;\n\nconst person: Person = &#123;\n    a: \"213\",\n    c: \"123\",\n    cb:()=>&#123;\n        console.log(123)\n    &#125;\n&#125;\n\n数组类型数组类型1.类型[ ] \n//类型加中括号\nlet arr:number[] = [123]\n//这样会报错定义了数字类型出现字符串是不允许的\nlet arr:number[] = [1,2,3,'1']\n//操作方法添加也是不允许的\nlet arr:number[] = [1,2,3,]\narr.unshift('1')\n\nvar arr: number[] = [1, 2, 3]; //数字类型的数组\nvar arr2: string[] = [\"1\", \"2\"]; //字符串类型的数组\nvar arr3: any[] = [1, \"2\", true]; //任意类型的数组\n\n\n\n数组泛型规则 Array&lt;类型&gt;\nlet arr:Array&lt;number> = [1,2,3,4,5]\n\n用接口表示数组一般用来描述类数组 \ninterface NumberArray &#123;\n    [index: number]: number;\n&#125;\nlet fibonacci: NumberArray = [1, 1, 2, 3, 5];\n//表示：只要索引的类型是数字时，那么值的类型必须是数字。\n\n多维数组let data:number[][] = [[1,2], [3,4]];\n\n\n\narguments类数组function Arr(...args:any): void &#123;\n    console.log(arguments)\n    //错误的arguments 是类数组不能这样定义\n    let arr:number[] = arguments\n&#125;\nArr(111, 222, 333)\n\n \n\nfunction Arr(...args:any): void &#123;\n    console.log(arguments) \n    //ts内置对象IArguments 定义\n    let arr:IArguments = arguments\n&#125;\nArr(111, 222, 333)\n\n//其中 IArguments 是 TypeScript 中定义好了的类型，它实际上就是：\ninterface IArguments &#123;\n\n[index: number]: any;\n\nlength: number;\ncallee: Function;\n&#125;\n\n\n\nany 在数组中的应用一个常见的例子数组中可以存在任意类型\nlet list: any[] = ['test', 1, [],&#123;a:1&#125;]\n\n函数扩展函数的类型//注意，参数不能多传，也不能少传 必须按照约定的类型来\nconst fn = (name: string, age:number): string => &#123;\n    return name + age\n&#125;\nfn('张三',18)\n\n\n\n函数的可选参数?//通过?表示该参数为可选参数\nconst fn = (name: string, age?:number): string => &#123;\n    return name + age\n&#125;\nfn('张三')\n\n\n\n函数参数的默认值const fn = (name: string = \"我是默认值\"): string => &#123;\n    return name\n&#125;\nfn()\n\n\n\n接口定义函数//定义参数 num 和 num2  ：后面定义返回值的类型\ninterface Add &#123;\n    (num:  number, num2: number): number\n&#125;\n\nconst fn: Add = (num: number, num2: number): number => &#123;\n    return num + num2\n&#125;\nfn(5, 5)\n\ninterface User&#123;\n    name: string;\n    age: number;\n&#125;\nfunction getUserInfo(user: User): User &#123;\n  return user\n&#125;\n\n\n\n定义剩余参数const fn = (array:number[],...items:any[]):any[] => &#123;\n       console.log(array,items)\n       return items\n&#125;\n\nlet a:number[] = [1,2,3]\n\nfn(a,'4','5','6')\n\n\n\n函数重载重载是方法名字相同，而参数不同，返回类型可以相同也可以不同。\n如果参数类型不同，则参数类型应设置为 any。\n参数数量不同你可以将不同的参数设置为可选。\nfunction fn(params: number): void\n\nfunction fn(params: string, params2: number): void\n\nfunction fn(params: any, params2?: any): void &#123;\n\n    console.log(params)\n     \n    console.log(params2)\n\n&#125;\n\n \n\nfn(123)\n\nfn('123',456)\n\n类型断言 | 联合类型 | 交叉类型联合类型//例如我们的手机号通常是13XXXXXXX 为数字类型 这时候产品说需要支持座机\n//所以我们就可以使用联合类型支持座机字符串\nlet myPhone: number | string  = '010-820'\n\n\n//这样写是会报错的应为我们的联合类型只有数字和字符串并没有布尔值\nlet myPhone: number | string  = true\n\n函数使用联合类型、\nconst fn = (something:number | boolean):boolean => &#123;\n     return !!something\n&#125;\n\n\n\n交叉类型多种类型的集合，联合对象将具有所联合类型的所有成员\ninterface People &#123;\n  age: number,\n  height： number\n&#125;\ninterface Man&#123;\n  sex: string\n&#125;\nconst xiaoman = (man: People &amp; Man) => &#123;\n  console.log(man.age)\n  console.log(man.height)\n  console.log(man.sex)\n&#125;\nxiaoman(&#123;age: 18,height: 180,sex: 'male'&#125;);\n\n\n\n类型断言语法：值 as 类型　　或　　&lt;类型&gt;值  value as string  value\ninterface A &#123;\n       run: string\n&#125;\n\ninterface B &#123;\n       build: string\n&#125;\n\nconst fn = (type: A | B): string => &#123;\n       return type.run\n&#125;\n//这样写是有警告的应为B的接口上面是没有定义run这个属性的\n\n\n\ninterface A &#123;\n       run: string\n&#125;\n\ninterface B &#123;\n       build: string\n&#125;\n\nconst fn = (type: A | B): string => &#123;\n       return (type as A).run\n&#125;\n//可以使用类型断言来推断他传入的是A接口的值\n\n需要注意的是，类型断言只能够「欺骗」TypeScript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误：\n使用any临时断言window.abc = 123\n//这样写会报错因为window没有abc这个东西\n(window as any).abc = 123\n//可以使用any临时断言在 any 类型的变量上，访问任何属性都是允许的。\n\n\n\nas const是对字面值的断言，与const直接定义常量是有区别的\n如果是普通类型跟直接const 声明是一样的\nconst names = '小满'\nnames = 'aa' //无法修改\n\n \n\n\nlet names2 = '小满' as const\nnames2 = 'aa' //无法修改\n// 数组\nlet a1 = [10, 20] as const;\nconst a2 = [10, 20];\n\na1.unshift(30); // 错误，此时已经断言字面量为[10, 20],数据无法做任何修改\na2.unshift(30); // 通过，没有修改指针\n\n\n\n类型断言是不具影响力的在下面的例子中，将 something 断言为 boolean 虽然可以通过编译，但是并没有什么用 并不会影响结果, 因为编译过程中会删除类型断言\nfunction toBoolean(something: any): boolean &#123;\n    return something as boolean;\n&#125;\n\ntoBoolean(1);\n// 返回值为 1\n\n内置对象JavaScript 中有很多内置对象，它们可以直接在 TypeScript 中当做定义好了的类型。\nECMAScript 的内置对象Boolean、Number、string、RegExp、Date、Error\n\nlet b: Boolean = new Boolean(1)\nconsole.log(b)\nlet n: Number = new Number(true)\nconsole.log(n)\nlet s: String = new String('哔哩哔哩关注小满zs')\nconsole.log(s)\nlet d: Date = new Date()\nconsole.log(d)\nlet r: RegExp = /^1/\nconsole.log(r)\nlet e: Error = new Error(\"error!\")\nconsole.log(e)\n\n\n\nDOM 和 BOM 的内置对象Document、HTMLElement、Event、NodeList 等\nlet body: HTMLElement = document.body;\nlet allDiv: NodeList = document.querySelectorAll('div');\n//读取div 这种需要类型断言 或者加个判断应为读不到返回null\nlet div:HTMLElement = document.querySelector('div') as HTMLDivElement\ndocument.addEventListener('click', function (e: MouseEvent) &#123;\n    \n&#125;);\n//dom元素的映射表\ninterface HTMLElementTagNameMap &#123;\n    \"a\": HTMLAnchorElement;\n    \"abbr\": HTMLElement;\n    \"address\": HTMLElement;\n    \"applet\": HTMLAppletElement;\n    \"area\": HTMLAreaElement;\n    \"article\": HTMLElement;\n    \"aside\": HTMLElement;\n    \"audio\": HTMLAudioElement;\n    \"b\": HTMLElement;\n    \"base\": HTMLBaseElement;\n    \"bdi\": HTMLElement;\n    \"bdo\": HTMLElement;\n    \"blockquote\": HTMLQuoteElement;\n    \"body\": HTMLBodyElement;\n    \"br\": HTMLBRElement;\n    \"button\": HTMLButtonElement;\n    \"canvas\": HTMLCanvasElement;\n    \"caption\": HTMLTableCaptionElement;\n    \"cite\": HTMLElement;\n    \"code\": HTMLElement;\n    \"col\": HTMLTableColElement;\n    \"colgroup\": HTMLTableColElement;\n    \"data\": HTMLDataElement;\n    \"datalist\": HTMLDataListElement;\n    \"dd\": HTMLElement;\n    \"del\": HTMLModElement;\n    \"details\": HTMLDetailsElement;\n    \"dfn\": HTMLElement;\n    \"dialog\": HTMLDialogElement;\n    \"dir\": HTMLDirectoryElement;\n    \"div\": HTMLDivElement;\n    \"dl\": HTMLDListElement;\n    \"dt\": HTMLElement;\n    \"em\": HTMLElement;\n    \"embed\": HTMLEmbedElement;\n    \"fieldset\": HTMLFieldSetElement;\n    \"figcaption\": HTMLElement;\n    \"figure\": HTMLElement;\n    \"font\": HTMLFontElement;\n    \"footer\": HTMLElement;\n    \"form\": HTMLFormElement;\n    \"frame\": HTMLFrameElement;\n    \"frameset\": HTMLFrameSetElement;\n    \"h1\": HTMLHeadingElement;\n    \"h2\": HTMLHeadingElement;\n    \"h3\": HTMLHeadingElement;\n    \"h4\": HTMLHeadingElement;\n    \"h5\": HTMLHeadingElement;\n    \"h6\": HTMLHeadingElement;\n    \"head\": HTMLHeadElement;\n    \"header\": HTMLElement;\n    \"hgroup\": HTMLElement;\n    \"hr\": HTMLHRElement;\n    \"html\": HTMLHtmlElement;\n    \"i\": HTMLElement;\n    \"iframe\": HTMLIFrameElement;\n    \"img\": HTMLImageElement;\n    \"input\": HTMLInputElement;\n    \"ins\": HTMLModElement;\n    \"kbd\": HTMLElement;\n    \"label\": HTMLLabelElement;\n    \"legend\": HTMLLegendElement;\n    \"li\": HTMLLIElement;\n    \"link\": HTMLLinkElement;\n    \"main\": HTMLElement;\n    \"map\": HTMLMapElement;\n    \"mark\": HTMLElement;\n    \"marquee\": HTMLMarqueeElement;\n    \"menu\": HTMLMenuElement;\n    \"meta\": HTMLMetaElement;\n    \"meter\": HTMLMeterElement;\n    \"nav\": HTMLElement;\n    \"noscript\": HTMLElement;\n    \"object\": HTMLObjectElement;\n    \"ol\": HTMLOListElement;\n    \"optgroup\": HTMLOptGroupElement;\n    \"option\": HTMLOptionElement;\n    \"output\": HTMLOutputElement;\n    \"p\": HTMLParagraphElement;\n    \"param\": HTMLParamElement;\n    \"picture\": HTMLPictureElement;\n    \"pre\": HTMLPreElement;\n    \"progress\": HTMLProgressElement;\n    \"q\": HTMLQuoteElement;\n    \"rp\": HTMLElement;\n    \"rt\": HTMLElement;\n    \"ruby\": HTMLElement;\n    \"s\": HTMLElement;\n    \"samp\": HTMLElement;\n    \"script\": HTMLScriptElement;\n    \"section\": HTMLElement;\n    \"select\": HTMLSelectElement;\n    \"slot\": HTMLSlotElement;\n    \"small\": HTMLElement;\n    \"source\": HTMLSourceElement;\n    \"span\": HTMLSpanElement;\n    \"strong\": HTMLElement;\n    \"style\": HTMLStyleElement;\n    \"sub\": HTMLElement;\n    \"summary\": HTMLElement;\n    \"sup\": HTMLElement;\n    \"table\": HTMLTableElement;\n    \"tbody\": HTMLTableSectionElement;\n    \"td\": HTMLTableDataCellElement;\n    \"template\": HTMLTemplateElement;\n    \"textarea\": HTMLTextAreaElement;\n    \"tfoot\": HTMLTableSectionElement;\n    \"th\": HTMLTableHeaderCellElement;\n    \"thead\": HTMLTableSectionElement;\n    \"time\": HTMLTimeElement;\n    \"title\": HTMLTitleElement;\n    \"tr\": HTMLTableRowElement;\n    \"track\": HTMLTrackElement;\n    \"u\": HTMLElement;\n    \"ul\": HTMLUListElement;\n    \"var\": HTMLElement;\n    \"video\": HTMLVideoElement;\n    \"wbr\": HTMLElement;\n&#125;\n\n元组类型如果需要一个固定大小的不同类型值的集合，我们需要使用元组。 \n元组就是数组的变种元组（Tuple）是固定数量的不同类型的元素的组合。\n元组与集合的不同之处在于，元组中的元素类型可以是不同的，而且数量固定。元组的好处在于可以把多个元素作为一个单元传递。如果一个方法需要返回多个值，可以把这多个值作为元组返回，而不需要创建额外的类来表示。\nlet arr:[number,string] = [1,'string']\n\nlet arr2: readonly [number,boolean,string,undefined] = [1,true,'sring',undefined]\n\n当赋值或访问一个已知索引的元素时，会得到正确的类型：\nlet arr:[number,string] = [1,'string']\narr[0].length //error\narr[1].length //success\n\n//数字是没有length 的\n\n\n\n越界元素let arr:[number,string] = [1,'string']\n\narr.push(true)//error\n\n对于越界的元素他的类型被限制为 联合类型（就是你在元组中定义的类型）\n应用场景 例如定义excel返回的数据let excel: [string, string, number, string][] = [\n    ['title', 'name', 1, '123'],\n    ['title', 'name', 1, '123'],\n    ['title', 'name', 1, '123'],\n    ['title', 'name', 1, '123'],\n    ['title', 'name', 1, '123'],\n]\n\n枚举类型在javaScript中是没有枚举的概念的TS帮我们定义了枚举这个类型\n使用枚举 通过enum关键字定义我们的枚举\n1.数字枚举例如 红绿蓝 Red = 0 Green = 1 Blue= 2 分别代表红色0 绿色为1 蓝色为2\nenum Types&#123;\n   Red,\n   Green,\n   BLue\n&#125;\n\n这样写就可以实现应为ts定义的枚举中的每一个组员默认都是从0开始的所以也就是\nenum Types&#123;\n   Red = 0,\n   Green = 1,\n   BLue = 2\n&#125;\n//默认就是从0开始的 可以不写值\n\n增长枚举\nenum Types&#123;\n   Red = 1,\n   Green,\n   BLue\n&#125;\n\n如上，我们定义了一个数字枚举， Red使用初始化为 1。 其余的成员会从 1开始自动增长。 换句话说， Type.Red的值为 1， Green为 2， Blue为 3。\n2.字符串枚举字符串枚举的概念很简单。 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。\nenum Types&#123;\n   Red = 'red',\n   Green = 'green',\n   BLue = 'blue'\n&#125;\n\n由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。 换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的 - 它并不能表达有用的信息，字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字。\n3.异构枚举枚举可以混合字符串和数字成员\nenum Types&#123;\n   No = \"No\",\n   Yes = 1,\n&#125;\n\n4.接口枚举定义一个枚举Types 定义一个接口A 他有一个属性red 值为Types.yyds\n声明对象的时候要遵循这个规则\n enum Types &#123;\n    yyds,\n    dddd\n &#125;\n interface A &#123;\n    red:Types.yyds\n &#125;\n \n let obj:A = &#123;\n    red:Types.yyds\n &#125;\n\n\n\n5.const枚举let  和 var 都是不允许的声明只能使用const\n大多数情况下，枚举是十分有效的方案。 然而在某些情况下需求很严格。 为了避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问，我们可以使用 const枚举。 常量枚举通过在枚举上使用 const修饰符来定义\nconst 声明的枚举会被编译成常量\n普通声明的枚举编译完后是个对象\nconst enum Types&#123;\n   No = \"No\",\n   Yes = 1,\n&#125;\n\n\n\n6.反向映射它包含了正向映射（ name -&gt; value）和反向映射（ value -&gt; name）\n要注意的是 不会为字符串枚举成员生成反向映射。\nenum Enum &#123;\n   fall\n&#125;\nlet a = Enum.fall;\nconsole.log(a); //0\nlet nameOfA = Enum[a]; \nconsole.log(nameOfA); //fall\n\nnever类型TypeScript 将使用 never 类型来表示不应该存在的状态(很抽象是不是)\n// 返回never的函数必须存在无法达到的终点\n\n// 因为必定抛出异常，所以 error 将不会有返回值\nfunction error(message: string): never &#123;\n    throw new Error(message);\n&#125;\n\n// 因为存在死循环，所以 loop 将不会有返回值\nfunction loop(): never &#123;\n    while (true) &#123;\n    &#125;\n&#125;\n\n\n\nnever 与 void 的差异//void类型只是没有返回值 但本身不会出错\nfunction Void():void &#123;\n\tconsole.log();\n&#125;\n//只会抛出异常没有返回值\nfunction Never():never &#123;\nthrow new Error('aaa')\n&#125;\nnever 类型的一个应用场景举一个我们可能会见到的例子\ninterface A &#123;\n    type: \"foo\"\n&#125;\n\ninterface B &#123;\n    type: \"bar\"\n&#125;\ntype All = A | B ;\nfunction handleValue(val: All) &#123;\n    switch (val.type) &#123;\n        case 'foo':\n            break;\n        case 'bar':\n            break\n        default:\n            //兜底逻辑 一般是不会进入这儿如果进来了就是程序异常了\n            \n\n            const exhaustiveCheck:never = val;\n            break\n    &#125;\n\n&#125;\n\n\n\n比如新来了一个同事他新增了一个C接口，我们必须手动找到所有 switch 代码并处理，否则将有可能引入 BUG 。\n而且这将是一个“隐蔽型”的BUG，如果回归面不够广，很难发现此类BUG。\n那 TS 有没有办法帮助我们在类型检查阶段发现这个问题呢？\ninterface A &#123;\n    type: \"foo\"\n&#125;\n\ninterface B &#123;\n    type: \"bar\"\n&#125;\ninterface C &#123;\n    type: \"bizz\"\n&#125;\ntype All = A | B | C;\nfunction handleValue(val: All) &#123;\n    switch (val.type) &#123;\n        case 'foo':\n            break;\n        case 'bar':\n            break\n        default:\n            //兜底逻辑 一般是不会进入这儿如果进来了就是程序异常了\n\t\tconst exhaustiveCheck: never = val;\n        break\n\t&#125;\n&#125;\n\n由于任何类型都不能赋值给 never 类型的变量，所以当存在进入 default 分支的可能性时，TS的类型检查会及时帮我们发现这个问题\nSymbol自ECMAScript 2015起，symbol成为了一种新的原生类型，就像number和string一样。symbol类型的值是通过Symbol构造函数创建的。\n可以传递参做为唯一标识 只支持 string 和 number类型的参数\nlet sym1 = Symbol();\nlet sym2 = Symbol(\"key\"); // 可选的字符串key\n\n\n\nSymbol的值是唯一的const s1 = Symbol()\nconst s2 = Symbol()\n// s1 === s2 =>false\n\n\n\n用作对象属性的键let sym = Symbol();\n\nlet obj = &#123;\n    [sym]: \"value\"\n&#125;;\n\nconsole.log(obj[sym]); // \"value\"\n\n使用symbol定义的属性，是不能通过如下方式遍历拿到的\nconst symbol1 = Symbol('666')\nconst symbol2 = Symbol('777')\nconst obj1= &#123;\n\n[symbol1]: '小满',\n[symbol2]: '二蛋',\n\n   age: 19,\n   sex: '女'\n&#125;\n// 1 for in 遍历\nfor (const key in obj1) &#123;\n   // 注意在console看key,是不是没有遍历到symbol1\n   console.log(key)\n&#125;\n// 2 Object.keys 遍历\nObject.keys(obj1)\nconsole.log(Object.keys(obj1))\n// 3 getOwnPropertyNames\nconsole.log(Object.getOwnPropertyNames(obj1))\n// 4 JSON.stringfy\nconsole.log(JSON.stringify(obj1))\n\n如何拿到\n// 1 拿到具体的symbol 属性,对象中有几个就会拿到几个\nObject.getOwnPropertySymbols(obj1)\nconsole.log(Object.getOwnPropertySymbols(obj1))\n// 2 es6 的 Reflect 拿到对象的所有属性\nReflect.ownKeys(obj1)\nconsole.log(Reflect.ownKeys(obj1))\n\n\n\nSymbol.iterator 迭代器 和 生成器 for of支持遍历大部分类型迭代器 arr nodeList argumetns set map 等\nvar arr = [1,2,3,4];\nlet iterator = arr[Symbol.iterator]();\n\nconsole.log(iterator.next());  //&#123; value: 1, done: false &#125;\nconsole.log(iterator.next());  //&#123; value: 2, done: false &#125;\nconsole.log(iterator.next());  //&#123; value: 3, done: false &#125;\nconsole.log(iterator.next());  //&#123; value: 4, done: false &#125;\nconsole.log(iterator.next());  //&#123; value: undefined, done: true &#125;\n\n测试用例\ninterface Item &#123;\n    age: number,\n    name: string\n&#125;\n\nconst array: Array&lt;Item> = [&#123; age: 123, name: \"1\" &#125;, &#123; age: 123, name: \"2\" &#125;, &#123; age: 123, name: \"3\" &#125;]\n\ntype mapTypes = string | number\nconst map:Map&lt;mapTypes,mapTypes> = new Map()\n\nmap.set('1','王爷')\nmap.set('2','陆北')\n\nconst obj = &#123;\n    aaa:123,\n    bbb:456\n&#125;\n\nlet set:Set&lt;number> = new Set([1,2,3,4,5,6])\n// let it:Iterator&lt;Item> = array[Symbol.iterator]()\nconst gen = (erg:any): void => &#123;\n    let it: Iterator&lt;any> = erg[Symbol.iterator]()\n    let next:any= &#123; done: false &#125;\n    while (!next.done) &#123;\n        next =  it.next()\n        if (!next.done) &#123;\n            console.log(next.value)\n        &#125;\n    &#125;\n&#125;\ngen(array)\n\n以下为这些symbols的列表：\nSymbol.hasInstance方法，会被instanceof运算符调用。构造器对象用来识别一个对象是否是其实例。\nSymbol.isConcatSpreadable布尔值，表示当在一个对象上调用Array.prototype.concat时，这个对象的数组元素是否可展开。\nSymbol.iterator方法，被for-of语句调用。返回对象的默认迭代器。\nSymbol.match方法，被String.prototype.match调用。正则表达式用来匹配字符串。\nSymbol.replace方法，被String.prototype.replace调用。正则表达式用来替换字符串中匹配的子串。\nSymbol.search方法，被String.prototype.search调用。正则表达式返回被匹配部分在字符串中的索引。\nSymbol.species函数值，为一个构造函数。用来创建派生对象。\nSymbol.split方法，被String.prototype.split调用。正则表达式来用分割字符串。\nSymbol.toPrimitive方法，被ToPrimitive抽象操作调用。把对象转换为相应的原始值。\nSymbol.toStringTag方法，被内置方法Object.prototype.toString调用。返回创建对象时默认的字符串描述。\nSymbol.unscopables对象，它自己拥有的属性会被with作用域排除在外。\n","slug":"TypeScript/01.typescript数据类型","date":"2023-02-04T05:49:52.000Z","categories_index":"TypeScript","tags_index":"TypeScript","author_index":"chenin"},{"id":"6cfd9c2293bfbcc79930156aac5124e0","title":"WebStorm 2019.3.1激活码","content":"下面正式开始激活（WebStorm 2019.3.1版） WebStorm 资源链接：https://pan.baidu.com/s/1UibJECYNiFuJrG2l89c-xw  提取码：w8y7。 jetbrains-agent 资源链接：http://note.youdao.com/noteshare?id=d0bf10ac54960b8eb02c532b6ecba84f 上面是安装包，下面是补丁文件。\n\n把补丁文件 jetbrains-agent.jar 放到webStorm安装目录的bin文件夹下。 我的是默认装在C盘了：C:\\Program Files\\JetBrains\\WebStorm 2019.3.1\\bin。\n\n找到这个bin文件夹下的webstorm.exe.vmoptions和webstorm64.exe.vmoptions文件。\n\n在两个文件最后一行都加上-javaagent:。\n\n运行webStorm，输入配套的激活码：\n3AGXEJXFK9-eyJsaWNlbnNlSWQiOiIzQUdYRUpYRks5IiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly96aGlsZS5pbyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9XSwiaGFzaCI6IjEyNzk2ODc3LzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-WGTHs6XpDhr+uumvbwQPOdlxWnQwgnGaL4eRnlpGKApEEkJyYvNEuPWBSrQkPmVpim/8Sab6HV04Dw3IzkJT0yTc29sPEXBf69+7y6Jv718FaJu4MWfsAk/ZGtNIUOczUQ0iGKKnSSsfQ/3UoMv0q/yJcfvj+me5Zd/gfaisCCMUaGjB/lWIPpEPzblDtVJbRexB1MALrLCEoDv3ujcPAZ7xWb54DiZwjYhQvQ+CvpNNF2jeTku7lbm5v+BoDsdeRq7YBt9ANLUKPr2DahcaZ4gctpHZXhG96IyKx232jYq9jQrFDbQMtVr3E+GsCekMEWSD//dLT+HuZdc1sAIYrw==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g==\n\n\n激活成功后点击菜单栏Help选项下的About，出现如下界面：可以使用到2089年7月8日，是不是相当于永久激活了。\n\nPS：还是不行的话建议还是拥抱vsCode吧，基本的代码规范、格式化代码配置在这篇文章中会有详细的讲解，传送门 https://www.jianshu.com/p/c6e140d62ce8\n经过一位读者朋友的留言，大版本2020.1已经不需要注册码和修改配置文件了。直接通过拖动配置文件就可以激活，而且可以汉化简体中文，https://www.789zhao.com/blog/J7ZT190UM7ZB.html  这里我没有去尝试，大家可以试试。\n原文链接: https://www.jianshu.com/p/d120ab55bfdd\n","slug":"WebStorm","date":"2021-04-21T13:42:00.000Z","categories_index":"软件工具","tags_index":"WebStorm,软件激活","author_index":"chenin"},{"id":"d2b17992ae092d8ffe2150a17d7a79d0","title":"koa学习笔记","content":"初始化项目# 初始化package.json\nnpm init\n\n# 安装koa2 \nnpm install koa\n\nhello world 代码 const Koa = require('koa');    //引入Koa框架\n\n const app = new Koa();\n\napp.use( async ctx => &#123;\n    ctx.body = 'Hello Koa';\n&#125;)\n\n// 监听3000端口\n app.listen(3000,() => &#123;\n    console.log('Server running at port 3000!');\n &#125;)\n\n\n\nnode app.js         // 启动服务\n\n\n\nasync/await的使用function getSyncTime() &#123;\n  return new Promise((resolve, reject) => &#123;\n    try &#123;\n      let startTime = new Date().getTime()\n      setTimeout(() => &#123;\n        let endTime = new Date().getTime()\n        let data = endTime - startTime\n        resolve( data )\n      &#125;, 500)\n    &#125; catch ( err ) &#123;\n      reject( err )\n    &#125;\n  &#125;)\n&#125;\n\nasync function getSyncData() &#123;\n  let time = await getSyncTime()\n  let data = `endTime - startTime = $&#123;time&#125;`\n  return data\n&#125;\n\nasync function getData() &#123;\n  let data = await getSyncData()\n  console.log( data )\n&#125;\n\ngetData()\n\n从上述例子可以看出 async/await 的特点：\n可以让异步逻辑用同步写法实现\n最底层的await返回需要是Promise对象\n可以通过多层 async function 的同步写法代替传统的callback嵌套\n\nkoa-router中间件安装koa-router中间件npm i koa-router --save\n\nkoa-router的使用 const Koa = require('koa');    //引入Koa框架\n const Router = require('koa-router');  //引入koa-router 中间件\n\n// 实例化 app\n const app = new Koa();\n\n\n// 路由\nconst router = new Router();\n\nrouter.get('/', async (ctx) => &#123;\n    ctx.body = 'Router 请求';\n&#125;);\n\n// 配置路由\napp.use(router.routes()).use(router.allowedMethods());\n\n\n// 监听3000端口\n app.listen(3000,() => &#123;\n    console.log('Server running at port 3000!');\n &#125;)\n\n\n\n请求数据获取GTET请求数据获取 const Koa = require('koa');    //引入Koa框架\n const Router = require('koa-router');  //引入koa-router 中间件\n\n// 实例化 app\n const app = new Koa();\n\n\n// 路由\nconst router = new Router();\n\nrouter.get('/user', async (ctx) => &#123;\n    let url = ctx.url\n    // 从上下文的request对象中获取\n    let request = ctx.request\n    let req_query = request.query\n    let req_querystring = request.querystring\n\n    // 从上下文中直接获取\n    let ctx_query = ctx.query\n    let ctx_querystring = ctx.querystring\n\n    ctx.body = &#123;\n      url,\n      req_query,\n      req_querystring,\n      ctx_query,\n      ctx_querystring\n    &#125;\n&#125;);\n\n// 配置路由\napp.use(router.routes()).use(router.allowedMethods());\n\n\n// 监听3000端口\n app.listen(3000,() => &#123;\n    console.log('Server running at port 3000!');\n &#125;)\n\n\nPOST请求数据获取koa-bodyparser中间件npm install koa-body --save\n const Koa = require('koa');    //引入Koa框架\n const Router = require('koa-router');  //引入koa-router 中间件\n\n const bodyParser = require('koa-bodyparser');\n\n// 实例化 app\n const app = new Koa();\n\n // 使用ctx.body解析中间件\napp.use(bodyParser());\n/* 支持json,form,text类型\napp.use(bodyparser(&#123;\n  enableTypes:['json', 'form', 'text']\n&#125;))\n*/\n// 路由\nconst router = new Router();\n\n\nrouter.post('/login', async ctx => &#123;\n    console.log(ctx.request.body);\n&#125;)\n\n// 配置路由\napp.use(router.routes()).use(router.allowedMethods());\n\n\n// 监听3000端口\n app.listen(3000,() => &#123;\n    console.log('Server running at port 3000!');\n &#125;)\n\n\n\n静态资源加载koa-static中间件使用const Koa = require('koa');\nconst path = require('path');\nconst static = require('koa-static');\n\nconst app = new Koa();\n\n// 静态资源目录对于相对入口文件index.js的路径\nconst staticPath = './static'\n\napp.use(static(\n  path.join( __dirname,  staticPath)\n))\n\n\napp.use( async ( ctx ) => &#123;\n  ctx.body = 'hello world'\n&#125;)\n\n\napp.listen(3000);\n\n\n\nkoa-static-router中间件, 实现多个&amp;&amp;多层路由加载静态资源npm install koa-static-router\n\n简单配置app.use(static('public'))      //默认配置: &#123;dir:public  route:'/public'&#125;\n\n单个路由const static = require('koa-static-router');\n app.use(static(&#123;\n     dir,  //静态资源目录对于相对入口文件index.js的路径\n     router   //路由命名\n &#125;))\n\n多个路由访问 localhost:3000/public/image/dir/1.png\n访问 localhost:3000/static/image/dir/2.png\nconst Koa = require('koa')\nconst app = new Koa()\nconst static = require('koa-static-router');\n\n\n// 单个路由\n// app.use(static(&#123;\n//     dir:'public',\n//     router:'/static/'     //路由长度 =1\n// &#125;))\n\n\n//多个路由\napp.use(static([\n    &#123;\n    dir:'public',    //静态资源目录对于相对入口文件index.js的路径\n    router:'/public/image/'   //路由命名   路由长度 =2\n&#125;,&#123;\n    dir:'static',   //静态资源目录对于相对入口文件index.js的路径\n    router:'/static/image/'    //路由命名  路由长度 =2\n&#125;\n]))\n\napp.use( async ( ctx ) => &#123;\n  ctx.body = 'hello world'\n&#125;)\n\napp.listen(3000, () => &#123;\n  console.log('build success')\n&#125;)\n\n\n\ncookie/sessionkoa2使用cookiekoa提供了从上下文直接读取、写入cookie的方法\n\nctx.cookies.get(name, [options]) 读取上下文请求中的cookie\nctx.cookies.set(name, value, [options]) 在上下文中写入cookie\n\nkoa2 中操作的cookies是使用了npm的cookies模块，源码在https://github.com/pillarjs/cookies，所以在读写cookie的使用参数与该模块的使用一致。\nconst Koa = require('koa')\nconst app = new Koa()\n\napp.use( async ( ctx ) => &#123;\n\n  if ( ctx.url === '/index' ) &#123;\n    ctx.cookies.set(\n      'cid', \n      'hello world',\n      &#123;\n        domain: 'localhost',  // 写cookie所在的域名\n        path: '/index',       // 写cookie所在的路径\n        maxAge: 10 * 60 * 1000, // cookie有效时长\n        expires: new Date('2017-02-15'),  // cookie失效时间\n        httpOnly: false,  // 是否只用于http请求中获取\n        overwrite: false  // 是否允许重写\n      &#125;\n    )\n    ctx.body = 'cookie is ok'\n  &#125; else &#123;\n    ctx.body = 'hello world' \n  &#125;\n\n&#125;)\n\napp.listen(3000, () => &#123;\n  console.log('[demo] cookie is starting at port 3000')\n&#125;)\n\n\nkoa2实现sessionkoa2原生功能只提供了cookie的操作，但是没有提供session操作。session就只用自己实现或者通过第三方中间件实现。在koa2中实现session的方案有一下几种\n\n如果session数据量很小，可以直接存在内存中\n如果session数据量很大，则需要存储介质存放session数据\n\nkoa-session的使用npm install koa-session --save\nconst Koa = require('koa')\nconst app = new Koa()\nconst Koa_Session = require('koa-session');      \n\n// 这个是配合signed属性的签名key\nconst session_signed_key = [\"some secret hurr\"]; \n// 配置\nconst session_config = &#123;\n    key: 'koa:sess', /**  cookie的key。 (默认是 koa:sess) */\n    maxAge: 10*60*1000,   /**  session 过期时间，以毫秒ms为单位计算 。*/\n    autoCommit: true, /** 自动提交到响应头。(默认是 true) */\n    overwrite: true, /** 是否允许重写 。(默认是 true) */\n    httpOnly: true, /** 是否设置HttpOnly，如果在Cookie中设置了\"HttpOnly\"属性，那么通过程序(JS脚本、Applet等)将无法读取到Cookie信息，这样能有效的防止XSS攻击。  (默认 true) */\n    signed: true, /** 是否签名。(默认是 true) */\n    rolling: true, /** 是否每次响应时刷新Session的有效期。(默认是 false) */\n    renew: false, /** 是否在Session快过期时刷新Session的有效期。(默认是 false) */\n&#125;;\n\n// 实例化\nconst session = Koa_Session(session_config, app)\napp.keys = session_signed_key;\n\n// 使用中间件，注意有先后顺序\napp.use(session);\n\napp.use( async ( ctx ) => &#123;\n\n  let n = ctx.session.views || 0;\n    ctx.session.views = ++n;\n    ctx.session.name = 'chen';\n    ctx.body = n + ' views';\n\n&#125;)\n\napp.listen(3000, () => &#123;\n  console.log('[demo] cookie is starting at port 3000')\n&#125;)\n\n\n使用ejs模板npm i koa-ejs --save\n/**\n * 项目入口文件\n */\n\nconst Koa = require('koa');\nconst app = new Koa();\nconst bodyParser = require('koa-bodyparser');\nconst Router = require('koa-router');\nconst router = new Router();\nconst render = require('koa-ejs');\nconst path = require('path');\napp.use(bodyParser());\n\n// 初始化ejs，设置后缀为html，文件目录为`views`\nrender(app, &#123;\n    root: path.join(__dirname, 'views'),\n    layout: false,\n    viewExt: 'html',\n    cache: false,\n    debug: false\n&#125;);\n\n\n// 渲染首页\nrouter.get('/',async (ctx,next)=>&#123;\n    await ctx.render('index',&#123;\n        title: '我是首页',\n        body: '我是内容啊'\n    &#125;);\n&#125;)\n\napp.use(router.routes());\napp.use(router.allowedMethods());\n// 监听3000端口\napp.listen(3000);\n\n\n\n\n连接mysql数据库安装Sequelizenpm install mysql2 --save\nnpm install sequelize --save\n\n\n\n使用 Sequelize 初始化连接池\n创建数据表模型\n数据表控制器\n数据路由表\n解决跨域问题npm i koa2-cors --save\n\n\n\nvar koa = require('koa');\nvar app = new koa();\nvar router = require('koa-router')();\nconst cors = require('koa2-cors');\napp.use(cors(&#123;\n  origin: '*',  // 允许来自所有域名请求\n   /* origin: function (ctx) &#123;\n        if (ctx.url === '/test') &#123;\n            return \"*\"; // 允许来自所有域名请求\n        &#125;\n        return 'http://localhost:8080'; / 这样就能只允许 http://localhost:8080 这个域名的请求了\n    &#125;,*/\n  exposeHeaders: ['WWW-Authenticate', 'Server-Authorization'],\n  maxAge: 5,\n  credentials: true,\n  allowMethods: ['GET', 'POST', 'DELETE'],\n  allowHeaders: ['Content-Type', 'Authorization', 'Accept'],\n&#125;));\nrouter.post('/', async function (ctx) &#123;\n    ctx.body = '恭喜 __小简__ 你成功登陆了'\n&#125;);\n \napp\n    .use(router.routes())\n    .use(router.allowedMethods());\n \napp.listen(3000);\n\n\n\n\n实现文件上传使用koa-multer 中间件npm install koa-multer --save\nconst multer = require('koa-multer');//加载koa-multer模块\n// 上传 图片\nvar storage = multer.diskStorage(&#123;\n        //文件保存路径\n        destination: function(req, file, cb) &#123;\n            cb(null, 'public/uploads/')\n        &#125;,\n        //修改文件名称\n        filename: function(req, file, cb) &#123;\n            var fileFormat = (file.originalname).split(\".\");\n            cb(null, Date.now() + \".\" + fileFormat[fileFormat.length - 1]);\n        &#125;\n    &#125;)\n    //加载配置\nvar upload = multer(&#123;\n    storage: storage\n&#125;);\nrouter.post('/upload', upload.single('file'), async(ctx, next) => &#123;\n    ctx.body = &#123;\n        filename: ctx.req.file.filename //返回文件名\n    &#125;\n&#125;)\n\n\n\n使用 koa-body 代替 koa-bodyparser 和 koa-multernpm i koa-body -S\nconst koaBody = require('koa-body');\nconst Router = require('koa-router');\nconst app = new koa();\napp.use(koaBody(&#123;\n  multipart:true, // 支持文件上传\n  encoding:'gzip',\n  formidable:&#123;\n    uploadDir:path.join(__dirname,'public/upload/'), // 设置文件上传目录\n    keepExtensions: true,    // 保持文件的后缀\n    maxFieldsSize:2 * 1024 * 1024, // 文件上传大小\n    onFileBegin:(name,file) => &#123; // 文件上传前的设置\n      // console.log(`name: $&#123;name&#125;`);\n      // console.log(file);\n    &#125;,\n  &#125;\n&#125;));\n\nconst router = new Router();\nrouter.post('/',async (ctx)=>&#123;\n  console.log(ctx.request.files);   //上传的文件信息\n  console.log(ctx.request.body);    //上传的所有信息\n  ctx.body = JSON.stringify(ctx.request.files);\n&#125;);\n\nkoa-body 的基本参数\n\n\n参数名\n描述\n类型\n默认值\n\n\n\npatchNode\n将请求体打到原生 node.js 的ctx.req中\nBoolean\nfalse\n\n\npatchKoa\n将请求体打到 koa 的 ctx.request 中\nBoolean\ntrue\n\n\njsonLimit\nJSON 数据体的大小限制\nString / Integer\n1mb\n\n\nformLimit\n限制表单请求体的大小\nString / Integer\n56kb\n\n\ntextLimit\n限制 text body 的大小\nString / Integer\n56kb\n\n\nencoding\n表单的默认编码\nString\nutf-8\n\n\nmultipart\n是否支持 multipart-formdate 的表单\nBoolean\nfalse\n\n\nurlencoded\n是否支持 urlencoded 的表单\nBoolean\ntrue\n\n\ntext\n是否解析 text/plain 的表单\nBoolean\ntrue\n\n\njson\n是否解析 json 请求体\nBoolean\ntrue\n\n\njsonStrict\n是否使用 json 严格模式，true 会只处理数组和对象\nBoolean\ntrue\n\n\nformidable\n配置更多的关于 multipart 的选项\nObject\n&#123;&#125;\n\n\nonError\n错误处理\nFunction\nfunction()&#123;&#125;\n\n\nstict\n严格模式,启用后不会解析 GET, HEAD, DELETE 请求\nBoolean\ntrue\n\n\nformidable 的相关配置参数\n\n\n参数名\n描述\n类型\n默认值\n\n\n\nmaxFields\n限制字段的数量\nInteger\n1000\n\n\nmaxFieldsSize\n限制字段的最大大小\nInteger\n2 * 1024 * 1024\n\n\nuploadDir\n文件上传的文件夹\nString\nos.tmpDir()\n\n\nkeepExtensions\n保留原来的文件后缀\nBoolean\nfalse\n\n\nhash\n如果要计算文件的 hash，则可以选择 md5/sha1\nString\nfalse\n\n\nmultipart\n是否支持多文件上传\nBoolean\ntrue\n\n\nonFileBegin\n文件上传前的一些设置操作\nFunction\nfunction(name,file)&#123;&#125;\n\n\n图片上传成功后，获取图片const fs = require('fs')\nconst app = new Koa()\nconst router = new Router()\nconst serve = require('koa-static')\nconst koaBody = require('koa-body')\n\napp\n    .use(serve(__dirname + '/files')) // files文件夹用于保存上传的文件,也是静态资源地址\n    .use(router.routes())\n\n// 前端使用formData方式组装数据\nrouter.post('/api/upload-files', koaBody(&#123; jsonLimit: '2mb', multipart: true &#125;), async (ctx) => &#123;\n    const data = ctx.request.body.files.data;\n    const savePath = path.join(`./files`, data.name)\n    const reader = fs.createReadStream(data.path)\n    const writer = fs.createWriteStream(savePath)\n\n    const pro = new Promise( (resolve, reject) => &#123;\n        var stream = reader.pipe(writer);\n\n        stream.on('finish', function () &#123;\n            resolve(`http://当前服务器地址$&#123;data.name&#125;`);\n        &#125;);\n    &#125;)\n    \n    ctx.response.body =  await pro\n    \n&#125;)\n\nkoa-send实现文件下载const send = require('koa-send');\n\nrouter.get('/download/:name', async (ctx) => &#123;\n    const name = ctx.params.name;\n    const path = `upload/$&#123;name&#125;`;\n    ctx.attachment(path);\n    await send(ctx, path);\n&#125;);\n\nkoa中间件记录koa的错误处理   koa-onerrornpm install koa-onerror --save\nvar onerror = require('Koa-onerror');\nonerror(app);\n\nkoa日志  koa-loggerapp.use(require('koa-logger'));\n// logger\napp.use(async (ctx, next) => &#123;\n  const start = new Date()\n  await next()\n  const ms = new Date() - start\n  console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;ms&#125;ms`)\n&#125;);\n\nkoa-json美观的输出JSON response的Koa中间件 有两种使用方式： 一种是总是返回美化了的json数据：\nconst json = require('koa-json');\napp.use(json());\n\n另一种是默认不进行美化，但是当地址栏传入pretty参数的时候，则返回的结果是进行了美化的。\napp.use(json(&#123; pretty: false, param: 'pretty' &#125;));\n\n\n\nkoa-jwt和jsonwebtoken进行token验证koa-jwt 主要提供路有权限控制的功能，它会对需要限制的资源请求进行检查\ntoken 默认被携带在Headers 中的名为Authorization的键值对中，koa-jwt也是在该位置获取token 的\napp.use(jwt(&#123; secret: &#39;shared-secret&#39;, key: &#39;jwtdata&#39; &#125;)) 可以使用另外一ctx key来表示解码数据，然后就可以通过ctx.state.jwtdata代替ctx.state.user获得解码数据\n\nsecret 的值可以使用函数代替，以此产生动态的加密秘钥\nkoa-jwt 依赖于jsonwebtoken和koa-unless两个库的\n\napp.use(jwt(&#123;\n    secret:'chambers'\n&#125;).unless(&#123;path:[/^\\/api/]&#125;));\n\n\n生成tokenconst router = require('koa-router')();\nconst jwt = require('jsonwebtoken');\nconst userModel = require('../models/userModel.js');\n\nrouter.post('/login', async (ctx) => &#123;\n    const data = ctx.request.body;\n    if(!data.name || !data.password)&#123;\n        return ctx.body = &#123;\n            code: '000002',\n            data: null,\n            msg: '参数不合法'\n        &#125;\n    &#125;\n    const result = await userModel.findOne(&#123;\n        name: data.name,\n        password: data.password\n    &#125;)\n    if(result !== null)&#123;\n        const token = jwt.sign(&#123;\n            name: result.name,\n            _id: result._id\n        &#125;, 'my_token', &#123; expiresIn: '2h' &#125;);\n        return ctx.body = &#123;\n            code: '000001',\n            data: token,\n            msg: '登录成功'\n        &#125;\n    &#125;else&#123;\n        return ctx.body = &#123;\n            code: '000002',\n            data: null,\n            msg: '用户名或密码错误'\n        &#125;\n    &#125;\n&#125;);\n\nmodule.exports = router;\n\n在验证了用户名密码正确之后，调用 jsonwebtoken 的 sign() 方法来生成token，接收三个参数，第一个是载荷，用于编码后存储在 token 中的数据，也是验证 token 后可以拿到的数据；第二个是密钥，自己定义的，验证的时候也是要相同的密钥才能解码；第三个是options，可以设置 token 的过期时间。\njwt.decode(token); 可以解析出sign（）中第一个参数。\n获取token前端请求头在Authorization中携带token，用于后台验证\n每次请求都要获取 localStorage 中的 token，这样很麻烦，这里使用了 axios 的请求拦截器，对每次请求都进行了取 token 放到 headers 中的操作。\naxios.interceptors.request.use(config => &#123;\n    const token = localStorage.getItem('token');\n    config.headers.common['Authorization'] = 'Bearer ' + token;\n    return config;\n&#125;)\n\n验证token通过 koa-jwt 中间件来进行验证\nconst koa = require('koa');\nconst koajwt = require('koa-jwt');\nconst app = new koa();\n\n// 错误处理\napp.use((ctx, next) => &#123;\n    return next().catch((err) => &#123;\n        if(err.status === 401)&#123;\n            ctx.status = 401;\n            ctx.body = 'Protected resource, use Authorization header to get access\\n';\n        &#125;else&#123;\n            throw err;\n        &#125;\n    &#125;)\n&#125;)\n\napp.use(koajwt(&#123;\n    secret: 'my_token'\n&#125;).unless(&#123;\n    path: [/\\/user\\/login/]\n&#125;));\n\n通过 app.use 来调用该中间件，并传入密钥 &#123;secret: &#39;my_token&#39;&#125;，unless 可以指定哪些 URL 不需要进行 token 验证。token 验证失败的时候会抛出401错误，因此需要添加错误处理，而且要放在 app.use(koajwt()) 之前，否则不执行。\n如果请求时没有token或者token过期，则会返回401。\n解析koa-jwt上面使用 jsonwebtoken 的 sign() 方法来生成 token 的，那么 koa-jwt 做了些什么帮我们来验证 token。\nresolvers/auth-header.jsmodule.exports = function resolveAuthorizationHeader(ctx, opts) &#123;\n    if (!ctx.header || !ctx.header.authorization) &#123;\n        return;\n    &#125;\n    const parts = ctx.header.authorization.split(' ');\n    if (parts.length === 2) &#123;\n        const scheme = parts[0];\n        const credentials = parts[1];\n        if (/^Bearer$/i.test(scheme)) &#123;\n            return credentials;\n        &#125;\n    &#125;\n    if (!opts.passthrough) &#123;\n        ctx.throw(401, 'Bad Authorization header format. Format is \"Authorization: Bearer &lt;token>\"');\n    &#125;\n&#125;;\n\n在 auth-header.js 中，判断请求头中是否带了 authorization，如果有，将 token 从 authorization 中分离出来。如果没有 authorization，则代表了客户端没有传 token 到服务器，这时候就抛出 401 错误状态。\nverify.jsconst jwt = require('jsonwebtoken');\n\nmodule.exports = (...args) => &#123;\n    return new Promise((resolve, reject) => &#123;\n        jwt.verify(...args, (error, decoded) => &#123;\n            error ? reject(error) : resolve(decoded);\n        &#125;);\n    &#125;);\n&#125;;\n\n在 verify.js 中，使用 jsonwebtoken 提供的 verify() 方法进行验证返回结果。jsonwebtoken 的 sign() 方法来生成 token 的，而 verify() 方法则是用来认证和解析 token。如果 token 无效，则会在此方法被验证出来。\nindex.jsconst decodedToken = await verify(token, secret, opts);\nif (isRevoked) &#123;\n    const tokenRevoked = await isRevoked(ctx, decodedToken, token);\n    if (tokenRevoked) &#123;\n        throw new Error('Token revoked');\n    &#125;\n&#125;\nctx.state[key] = decodedToken;  // 这里的key = 'user'\nif (tokenKey) &#123;\n    ctx.state[tokenKey] = token;\n&#125;\n\n在 index.js 中，调用 verify.js 的方法进行验证并解析 token，拿到上面进行 sign() 的数据 &#123;name: result.name, _id: result._id&#125;，并赋值给 ctx.state.user，在控制器中便可以直接通过 ctx.state.user 拿到 name 和 _id。\n安全性\n如果 JWT 的加密密钥泄露的话，那么就可以通过密钥生成 token，随意的请求 API 了。因此密钥绝对不能存在前端代码中，不然很容易就能被找到。\n在 HTTP 请求中，token 放在 header 中，中间者很容易可以通过抓包工具抓取到 header 里的数据。而 HTTPS 即使能被抓包，但是它是加密传输的，所以也拿不到 token，就会相对安全了。\n\nbcryptjs密码加密npm install bcryptjs --save\n\n同步用法(Sync)生成hash密码\nconst bcrypt = require('bcryptjs');\nconst salt = bcrypt.genSaltSync(10);\n// hash 加密后的密码       \"B4c0/\\/\"加密前的密码   \nvar hash = bcrypt.hashSync(\"B4c0/\\/\", salt);\n\n密码验证\nbcrypt.compareSync(\"B4c0/\\/\", hash); // true \nbcrypt.compareSync(\"not_bacon\", hash); // false\n\n快速生成hash值\nvar hash = bcrypt.hashSync('bacon', 8);\n\n异步用法(Async)生成hash密码\nvar bcrypt = require('bcryptjs');\nbcrypt.genSalt(10, function(err, salt) &#123;\n    bcrypt.hash(\"B4c0/\\/\", salt, function(err, hash) &#123;\n        // Store hash in your password DB. \n    &#125;);\n&#125;);\n\n密码验证\n// Load hash from your password DB. \nbcrypt.compare(\"B4c0/\\/\", hash, function(err, res) &#123;\n    // res === true \n&#125;);\nbcrypt.compare(\"not_bacon\", hash, function(err, res) &#123;\n    // res === false \n&#125;);\n \n// As of bcryptjs 2.4.0, compare returns a promise if callback is omitted: \nbcrypt.compare(\"B4c0/\\/\", hash).then((res) => &#123;\n    // res === true \n&#125;);\n\n快速生成hash值\nbcrypt.hash('bacon', 8, function(err, hash) &#123;\n&#125;);\n\n\n\n\n\nmoment 时间中间件markdown-it markdown语法","slug":"koa","date":"2021-04-10T10:02:55.000Z","categories_index":"Node.js","tags_index":"Koa,MySQL","author_index":"chenin"}]